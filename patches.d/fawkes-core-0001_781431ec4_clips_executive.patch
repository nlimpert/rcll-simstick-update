diff --git a/cfg/conf.d/clips-executive.yaml b/cfg/conf.d/clips-executive.yaml
index c16522d8e..c2d62f97a 100644
--- a/cfg/conf.d/clips-executive.yaml
+++ b/cfg/conf.d/clips-executive.yaml
@@ -59,8 +59,15 @@ clips-executive:
       #macro-expansion: test-scenario/action-selection.clp
       action-execution: plan-exec.clp
       execution-monitoring: test-scenario/execution-monitoring.clp
+      state-estimation: test-scenario/state-estimation.clp
 
       action-mapping:
         say: say{text=?(text)s, wait=true}
         say-hello: say{text="Hello ?(name)y", wait=true}
         say-goodbye: say{text="Good bye", wait=true}
+
+      # Interface _types_ mentioned in the following list will be pre-loaded,
+      # i.e., the fact templates will be created in stage2, before user-specified
+      # code is loaded. That avoid the necessity of splitting interface opening
+      # and processing in user code.
+      #blackboard-preload: ["Position3DInterface"]
diff --git a/cfg/conf.d/dynamixel.yaml b/cfg/conf.d/dynamixel.yaml
index 681694216..b06062315 100644
--- a/cfg/conf.d/dynamixel.yaml
+++ b/cfg/conf.d/dynamixel.yaml
@@ -68,3 +68,5 @@ dynamixel:
     autorecover_enabled: true
     autorecover_flags: 127
 
+    # Allow verbose output on messages received
+    enable_verbose_output: false
diff --git a/cfg/conf.d/joystick.yaml b/cfg/conf.d/joystick.yaml
index b54a6abe5..c3e0ad4da 100644
--- a/cfg/conf.d/joystick.yaml
+++ b/cfg/conf.d/joystick.yaml
@@ -7,6 +7,15 @@ doc-url: !url http://trac.fawkesrobotics.org/wiki/Plugins/joystick
   # Joystick device file
   device_file: /dev/input/js0
 
+  # Set this to true to allow that the joystick device is not
+  # present on plugin loading. The joystick will be initialized as
+  # soo as the device is available.
+  allow_deferred_initialization: true
+
+  # Time in seconds in which to retry opening the joystick
+  # if lost or during deferred initialization (float, sec)
+  retry_interval: 2.0
+
   safety_lockout:
     # True to enable safety lockout feature.
     # This feature requires that axes 0 and 1 (usually primary cross) must be
diff --git a/cfg/conf.d/webview.yaml b/cfg/conf.d/webview.yaml
index b237ee2fb..9e96e65de 100644
--- a/cfg/conf.d/webview.yaml
+++ b/cfg/conf.d/webview.yaml
@@ -64,4 +64,7 @@ webview:
       jpeg-vflip: false
 
   # directories with static files
-  static-dirs: ["@BASEDIR@/res/webview"]
\ No newline at end of file
+  static-dirs: ["@BASEDIR@/res/webview"]
+
+  syncpoints:
+    max_age: 3.0
diff --git a/src/libs/Makefile b/src/libs/Makefile
index 82320441c..46f64666f 100644
--- a/src/libs/Makefile
+++ b/src/libs/Makefile
@@ -20,7 +20,7 @@ include $(BUILDSYSDIR)/fvconf.mk
 SUBDIRS = core utils interface netcomm blackboard interfaces config logging tf \
 	  plugin lua aspect network_logger webview gui_utils baseapp navgraph \
 	  fvutils fvcams fvmodels fvfilters fvclassifiers fvstereo fvwidgets \
-	  kdl_parser protobuf_comm protobuf_clips pcl_utils
+	  kdl_parser protobuf_comm protobuf_clips pcl_utils syncpoint 
 
 ifeq ($(HAVE_SIFT),1)
   SUBDIRS += extlib/sift
@@ -46,7 +46,7 @@ navgraph: core utils aspect
 interfaces: core interface
 config: core netcomm utils logging
 plugin: core netcomm utils config logging
-aspect: core utils blackboard netcomm config plugin webview logging tf pcl_utils
+aspect: core utils blackboard netcomm config plugin webview logging tf pcl_utils syncpoint
 lua: core utils blackboard config logging
 interfaces: core interface
 gui_utils: core netcomm blackboard interface plugin logging utils
@@ -54,7 +54,7 @@ logging: core
 network_logger: core utils netcomm
 naoutils: core utils
 webview: core utils logging
-baseapp: core utils aspect config netcomm blackboard plugin logging network_logger
+baseapp: core utils aspect config netcomm blackboard plugin logging syncpoint network_logger
 tf: core utils blackboard interface interfaces
 fvutils: core utils netcomm logging
 fvcams fvmodels fvfilters fvclassifiers fvstereo fvwidgets: core utils fvutils logging
@@ -66,6 +66,7 @@ endif
 protobuf_clips: core logging protobuf_comm
 pcl_utils: core tf
 kdl_parser: core
+syncpoint: core logging utils
 
 include $(BUILDSYSDIR)/rules.mk
 include $(LIBSRCDIR)/extlibs.mk
diff --git a/src/libs/aspect/Makefile b/src/libs/aspect/Makefile
index 3bf954103..da5c69de0 100644
--- a/src/libs/aspect/Makefile
+++ b/src/libs/aspect/Makefile
@@ -20,7 +20,7 @@ include $(BUILDCONFDIR)/tf/tf.mk
 include $(BUILDSYSDIR)/pcl.mk
 
 LIBS_libfawkesaspects = fawkescore fawkesutils fawkesblackboard fawkesnetcomm \
-			fawkesconfig fawkesplugin fawkeslogging
+			fawkesconfig fawkesplugin fawkeslogging fawkessyncpoint
 
 ifneq ($(HAVE_WEBVIEW),1)
   OBJS_FILTER_OUT += $(subst $(SRCDIR)/,,$(wildcard $(SRCDIR)/webview.cpp $(SRCDIR)/inifins/webview.cpp))
diff --git a/src/libs/aspect/blocked_timing.cpp b/src/libs/aspect/blocked_timing.cpp
index 103ce8f6c..f070fc4c8 100644
--- a/src/libs/aspect/blocked_timing.cpp
+++ b/src/libs/aspect/blocked_timing.cpp
@@ -25,6 +25,7 @@
 #include <core/threading/thread.h>
 #include <core/exception.h>
 
+
 namespace fawkes {
 #if 0 /* just to make Emacs auto-indent happy */
 }
@@ -52,18 +53,45 @@ namespace fawkes {
  * @param wakeup_hook hook when this thread should be woken up
  */
 BlockedTimingAspect::BlockedTimingAspect(WakeupHook wakeup_hook)
+    : SyncPointAspect(SyncPoint::WAIT_FOR_ALL,
+        blocked_timing_hook_to_start_syncpoint(wakeup_hook),
+        blocked_timing_hook_to_end_syncpoint(wakeup_hook))
 {
   add_aspect("BlockedTimingAspect");
   __wakeup_hook = wakeup_hook;
+  __loop_listener = new BlockedTimingLoopListener();
 }
 
 
 /** Virtual empty destructor. */
 BlockedTimingAspect::~BlockedTimingAspect()
 {
+  delete __loop_listener;
 }
 
 
+/** Init BlockedTiming aspect.
+ * This intializes the aspect and adds the loop listener to the thread.
+ * @param thread thread which uses this aspect
+ */
+void
+BlockedTimingAspect::init_BlockedTimingAspect(Thread *thread)
+{
+  thread->add_loop_listener(__loop_listener);
+  thread->wakeup();
+}
+
+
+/** Finalize BlockedTiming aspect.
+ * This finalizes the aspect and removes the loop listener from the thread.
+ * @param thread thread which uses this aspect
+ */
+void
+BlockedTimingAspect::finalize_BlockedTimingAspect(Thread *thread)
+{
+  thread->remove_loop_listener(__loop_listener);
+}
+
 /** Get the wakeup hook.
  * The wakeup hook defines when this thread should be woken up. This heavily
  * depends on the used main thread.
@@ -75,7 +103,6 @@ BlockedTimingAspect::blockedTimingAspectHook() const
   return __wakeup_hook;
 }
 
-
 /** Get string for wakeup hook.
  * @param hook wakeup hook to get string for
  * @return string representation of hook
@@ -98,4 +125,58 @@ BlockedTimingAspect::blocked_timing_hook_to_string(WakeupHook hook)
   }
 }
 
+const std::map<const BlockedTimingAspect::WakeupHook, const std::string>
+BlockedTimingAspect::hook_to_syncpoint = {
+  { WAKEUP_HOOK_PRE_LOOP,       "/preloop" },
+  { WAKEUP_HOOK_SENSOR_ACQUIRE, "/sensors/acquire" },
+  { WAKEUP_HOOK_SENSOR_PREPARE, "/sensors/prepare" },
+  { WAKEUP_HOOK_SENSOR_PROCESS, "/sensors/process" },
+  { WAKEUP_HOOK_WORLDSTATE,     "/worldstate" },
+  { WAKEUP_HOOK_THINK,          "/agent" },
+  { WAKEUP_HOOK_SKILL,          "/skill" },
+  { WAKEUP_HOOK_ACT,            "/act/main" },
+  { WAKEUP_HOOK_ACT_EXEC,       "/act/exec" },
+  { WAKEUP_HOOK_POST_LOOP,      "/postloop" }
+};
+
+/** Get the syncpoint identifier corresponding to the end of a wakeup hook.
+ * This is the syncpoint emitted at the end of a hook.
+ * @param hook wakeup hook to get the syncpoint identifier for
+ * @return the identifier of the corresponding syncpoint
+ */
+std::string
+BlockedTimingAspect::blocked_timing_hook_to_end_syncpoint(WakeupHook hook)
+{
+  try {
+    return std::string(hook_to_syncpoint.at(hook)) + "/end";
+  } catch (const std::out_of_range &e) {
+    throw Exception("Unknown blocked timing wakeup hook. Error: %s", e.what());
+  }
+}
+
+/** Get the syncpoint identifier corresponding to the start of a wakeup hook.
+ * This is the syncpoint waited for at the start of a hook.
+ * @param hook wakeup hook to get the syncpoint identifier for
+ * @return the identifier of the corresponding syncpoint
+ */
+std::string
+BlockedTimingAspect::blocked_timing_hook_to_start_syncpoint(WakeupHook hook)
+{
+  try {
+    return std::string(hook_to_syncpoint.at(hook)) + "/start";
+  } catch (const std::out_of_range &e) {
+    throw Exception("Unknown blocked timing wakeup hook. Error: %s", e.what());
+  }
+}
+
+/** The post loop function of the BlockedTimingAspect
+ * This function is called right after the loop of the thread with the aspect.
+ * @param thread thread this loop listener belongs to
+ */
+void
+BlockedTimingLoopListener::post_loop(Thread *thread)
+{
+  thread->wakeup();
+}
+
 } // end namespace fawkes
diff --git a/src/libs/aspect/blocked_timing.h b/src/libs/aspect/blocked_timing.h
index 58c22d6f5..8093288f9 100644
--- a/src/libs/aspect/blocked_timing.h
+++ b/src/libs/aspect/blocked_timing.h
@@ -25,13 +25,33 @@
 #define __ASPECT_BLOCKED_TIMING_H_
 
 #include <aspect/aspect.h>
+#include <aspect/syncpoint.h>
+#include <core/threading/thread_loop_listener.h>
+
+#include <map>
+#include <string>
 
 namespace fawkes {
 #if 0 /* just to make Emacs auto-indent happy */
 }
 #endif
 
-class BlockedTimingAspect : public virtual Aspect
+
+/** @class BlockedTimingLoopListener
+ * Loop Listener of the BlockedTimingAspect.
+ * This loop listener immediately wakes up the thread after loop returned.
+ * The thread will then wait for the syncpoint of the next iteration.
+ * The BlockedTimingAspect cannot be derived from ThreadLoopListener because
+ * the SyncPointAspect is already derived from ThreadLoopListener and we need
+ * another listener. Therefore, use composition instead.
+ */
+class BlockedTimingLoopListener : public ThreadLoopListener
+{
+ public:
+  void post_loop(Thread *thread);
+};
+
+class BlockedTimingAspect : public SyncPointAspect
 {
  public:
   /** Type to define at which hook the thread is woken up.
@@ -59,10 +79,22 @@ class BlockedTimingAspect : public virtual Aspect
 
   static const char *  blocked_timing_hook_to_string(WakeupHook hook);
 
+  static std::string blocked_timing_hook_to_start_syncpoint(WakeupHook hook);
+  static std::string blocked_timing_hook_to_end_syncpoint(WakeupHook hook);
+
+  void init_BlockedTimingAspect(Thread *thread);
+  void finalize_BlockedTimingAspect(Thread *thread);
+
   WakeupHook blockedTimingAspectHook() const;
 
+  /** Translation from WakeupHooks to SyncPoints. Each WakeupHook corresponds to
+   *  exactly one SyncPoint, e.g., WAKEUP_HOOK_PRE_LOOP becomes /preloop.
+   */
+  static const std::map<const WakeupHook, const std::string> hook_to_syncpoint;
+
  private:
   WakeupHook __wakeup_hook;
+  BlockedTimingLoopListener *__loop_listener;
 };
 
 } // end namespace fawkes
diff --git a/src/libs/aspect/inifins/blocked_timing.cpp b/src/libs/aspect/inifins/blocked_timing.cpp
index dc69af8f4..1a39fd977 100644
--- a/src/libs/aspect/inifins/blocked_timing.cpp
+++ b/src/libs/aspect/inifins/blocked_timing.cpp
@@ -45,7 +45,7 @@ BlockedTimingAspectIniFin::BlockedTimingAspectIniFin()
 void
 BlockedTimingAspectIniFin::init(Thread *thread)
 {
-  BlockedTimingAspect *blocked_timing_thread __unused;
+  BlockedTimingAspect *blocked_timing_thread;
   blocked_timing_thread = dynamic_cast<BlockedTimingAspect *>(thread);
 
   if (blocked_timing_thread == 0) {
@@ -54,16 +54,28 @@ BlockedTimingAspectIniFin::init(Thread *thread)
 					  "has not. ", thread->name());
   }
 
-  if ( thread->opmode() != Thread::OPMODE_WAITFORWAKEUP ) {
+  if ( thread->opmode() != Thread::OPMODE_WAITFORWAKEUP) {
     throw CannotInitializeThreadException("Thread '%s' not in WAITFORWAKEUP mode"
-					  " (required for BlockedTimingAspect)",
-					  thread->name());
+                                          " (required for BlockedTimingAspect)",
+                                          thread->name());
   }
+
+  blocked_timing_thread->init_BlockedTimingAspect(thread);
 }
 
 void
 BlockedTimingAspectIniFin::finalize(Thread *thread)
 {
+  BlockedTimingAspect *blocked_timing_thread;
+    blocked_timing_thread = dynamic_cast<BlockedTimingAspect *>(thread);
+
+  if (blocked_timing_thread == 0) {
+    throw CannotInitializeThreadException("Thread '%s' claims to have the "
+      "BlockedTimingAspect, but RTTI says it "
+      "has not. ", thread->name());
+  }
+
+  blocked_timing_thread->finalize_BlockedTimingAspect(thread);
 }
 
 
diff --git a/src/libs/aspect/inifins/syncpoint.cpp b/src/libs/aspect/inifins/syncpoint.cpp
new file mode 100644
index 000000000..ab08a284c
--- /dev/null
+++ b/src/libs/aspect/inifins/syncpoint.cpp
@@ -0,0 +1,78 @@
+/***************************************************************************
+ *  syncpoint.cpp - SyncPoint Aspect initializer/finalizer
+ *
+ *  Created: Thu Feb 19 14:39:42 2015
+ *  Copyright  2015  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <aspect/inifins/syncpoint.h>
+#include <aspect/syncpoint.h>
+#include <syncpoint/syncpoint_manager.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointAspectIniFin <aspect/inifins/syncpoint.h>
+ * Initializer/finalizer for the SyncPointAspect
+ * @author Till Hofmann
+ */
+
+/** Constructor.
+ * @param syncpoint_manager SyncPointManager instance to pass to threads
+ */
+SyncPointAspectIniFin::SyncPointAspectIniFin(SyncPointManager *syncpoint_manager)
+: AspectIniFin("SyncPointAspect")
+{
+  __syncpoint_manager = syncpoint_manager;
+}
+
+void
+SyncPointAspectIniFin::init(Thread *thread)
+{
+  SyncPointAspect *syncpoint_thread;
+  syncpoint_thread = dynamic_cast<SyncPointAspect *>(thread);
+  if (syncpoint_thread == NULL) {
+    throw CannotInitializeThreadException("Thread '%s' claims to have the "
+        "SyncPointManagerAspect, but RTTI says it "
+        "has not. ", thread->name());
+  }
+
+  syncpoint_thread->init_SyncPointAspect(thread, __syncpoint_manager);
+
+}
+
+void
+SyncPointAspectIniFin::finalize(Thread *thread)
+{
+  SyncPointAspect *syncpoint_thread;
+  syncpoint_thread = dynamic_cast<SyncPointAspect *>(thread);
+  if (syncpoint_thread == NULL) {
+    throw CannotInitializeThreadException("Thread '%s' claims to have the "
+        "SyncPointManagerAspect, but RTTI says it "
+        "has not. ", thread->name());
+  }
+
+  syncpoint_thread->finalize_SyncPointAspect(thread, __syncpoint_manager);
+
+}
+
+
+} // end namespace fawkes
+
+
diff --git a/src/libs/aspect/inifins/syncpoint.h b/src/libs/aspect/inifins/syncpoint.h
new file mode 100644
index 000000000..7b79c7b17
--- /dev/null
+++ b/src/libs/aspect/inifins/syncpoint.h
@@ -0,0 +1,48 @@
+/***************************************************************************
+ *  syncpoint.h - SyncPoint Aspect initializer/finalizer
+ *
+ *  Created: Thu Feb 19 14:39:42 2015
+ *  Copyright  2015  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __ASPECT_INIFINS_SYNCPOINT_H_
+#define __ASPECT_INIFINS_SYNCPOINT_H_
+
+#include <aspect/inifins/inifin.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointManager;
+
+class SyncPointAspectIniFin : public AspectIniFin
+{
+ public:
+    SyncPointAspectIniFin(SyncPointManager *syncpoint_manager);
+
+    virtual void init(Thread *thread);
+    virtual void finalize(Thread *thread);
+
+  private:
+    SyncPointManager *__syncpoint_manager;
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/aspect/inifins/syncpoint_manager.cpp b/src/libs/aspect/inifins/syncpoint_manager.cpp
new file mode 100644
index 000000000..18bf7d117
--- /dev/null
+++ b/src/libs/aspect/inifins/syncpoint_manager.cpp
@@ -0,0 +1,70 @@
+/***************************************************************************
+ *  syncpoint_manager.cpp - SyncPointManager Aspect initializer/finalizer
+ *
+ *  Created: Wed Jan 15 13:19:22 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <aspect/inifins/syncpoint_manager.h>
+#include <aspect/syncpoint_manager.h>
+#include <syncpoint/syncpoint_manager.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointManagerAspectIniFin <aspect/inifins/syncpoint_manager.h>
+ * Initializer/finalizer for the SyncPointManagerAspect
+ * @author Till Hofmann
+ */
+
+/** Constructor.
+ * @param syncpoint_manager SyncPointManager instance to pass to threads
+ */
+SyncPointManagerAspectIniFin::SyncPointManagerAspectIniFin(SyncPointManager *syncpoint_manager)
+: AspectIniFin("SyncPointManagerAspect")
+{
+  __syncpoint_manager = syncpoint_manager;
+}
+
+void
+SyncPointManagerAspectIniFin::init(Thread *thread)
+{
+  SyncPointManagerAspect *syncpoint_thread;
+  syncpoint_thread = dynamic_cast<SyncPointManagerAspect *>(thread);
+  if (syncpoint_thread == NULL) {
+    throw CannotInitializeThreadException("Thread '%s' claims to have the "
+        "SyncPointManagerAspect, but RTTI says it "
+        "has not. ", thread->name());
+  }
+
+  syncpoint_thread->init_SyncPointManagerAspect(__syncpoint_manager);
+
+}
+
+
+void
+SyncPointManagerAspectIniFin::finalize(Thread *thread)
+{
+
+}
+
+
+} // end namespace fawkes
+
+
diff --git a/src/libs/aspect/inifins/syncpoint_manager.h b/src/libs/aspect/inifins/syncpoint_manager.h
new file mode 100644
index 000000000..d568492a7
--- /dev/null
+++ b/src/libs/aspect/inifins/syncpoint_manager.h
@@ -0,0 +1,49 @@
+/***************************************************************************
+ *  syncpoint_manager.h - SyncPointManager Aspect initializer/finalizer
+ *
+ *  Created: Wed Jan 15 13:17:12 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __ASPECT_INIFINS_SYNCPOINTMANAGER_H_
+#define __ASPECT_INIFINS_SYNCPOINTMANAGER_H_
+
+#include <aspect/inifins/inifin.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointManager;
+
+class SyncPointManagerAspectIniFin : public AspectIniFin
+{
+  public:
+    SyncPointManagerAspectIniFin(SyncPointManager *syncpoint_manager);
+
+    virtual void init(Thread *thread);
+    virtual void finalize(Thread *thread);
+
+  private:
+    SyncPointManager *__syncpoint_manager;
+
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/aspect/manager.cpp b/src/libs/aspect/manager.cpp
index 86a4637d0..6eb677505 100644
--- a/src/libs/aspect/manager.cpp
+++ b/src/libs/aspect/manager.cpp
@@ -37,6 +37,8 @@
 #include <aspect/inifins/time_source.h>
 #include <aspect/inifins/vision_master.h>
 #include <aspect/inifins/vision.h>
+#include <aspect/inifins/syncpoint_manager.h>
+#include <aspect/inifins/syncpoint.h>
 #ifdef HAVE_WEBVIEW
 #  include <aspect/inifins/webview.h>
 #endif
@@ -221,6 +223,7 @@ AspectManager::prepare_finalize(Thread *thread)
  * @param service_browser service browser for NetworkAspect
  * @param pmanager plugin manager for PluginDirectorAspect
  * @param tf_listener transformer for TransformAspect
+ * @param syncpoint_manager manager for SyncPointManagerAspect
  */
 void
 AspectManager::register_default_inifins(BlackBoard *blackboard,
@@ -236,7 +239,8 @@ AspectManager::register_default_inifins(BlackBoard *blackboard,
 					ServicePublisher *service_publisher,
 					ServiceBrowser *service_browser,
 					PluginManager *pmanager,
-					tf::Transformer *tf_listener)
+					tf::Transformer *tf_listener,
+					SyncPointManager *syncpoint_manager)
 {
   if (! __default_inifins.empty())  return;
 
@@ -258,6 +262,8 @@ AspectManager::register_default_inifins(BlackBoard *blackboard,
   TimeSourceAspectIniFin *ts_aif = new TimeSourceAspectIniFin(clock);
   VisionMasterAspectIniFin *vm_aif = new VisionMasterAspectIniFin();
   VisionAspectIniFin *vis_aif = new VisionAspectIniFin(vm_aif);
+  SyncPointManagerAspectIniFin *spm_aif = new SyncPointManagerAspectIniFin(syncpoint_manager);
+  SyncPointAspectIniFin *sp_aif = new SyncPointAspectIniFin(syncpoint_manager);
 #ifdef HAVE_WEBVIEW
   WebviewAspectIniFin *web_aif = new WebviewAspectIniFin();
 #endif
@@ -284,6 +290,8 @@ AspectManager::register_default_inifins(BlackBoard *blackboard,
   __default_inifins[ts_aif->get_aspect_name()] = ts_aif;
   __default_inifins[vm_aif->get_aspect_name()] = vm_aif;
   __default_inifins[vis_aif->get_aspect_name()] = vis_aif;
+  __default_inifins[spm_aif->get_aspect_name()] = spm_aif;
+  __default_inifins[sp_aif->get_aspect_name()] = sp_aif;
 #ifdef HAVE_WEBVIEW
   __default_inifins[web_aif->get_aspect_name()] = web_aif;
 #endif
diff --git a/src/libs/aspect/manager.h b/src/libs/aspect/manager.h
index 561c5ba3b..39a57c49e 100644
--- a/src/libs/aspect/manager.h
+++ b/src/libs/aspect/manager.h
@@ -51,6 +51,7 @@ class LoggerEmployer;
 class BlockedTimingExecutor;
 class MainLoopEmployer;
 class AspectIniFin;
+class SyncPointManager;
 
 namespace tf {
   class Transformer;
@@ -83,7 +84,8 @@ class AspectManager : public ThreadInitializer, public ThreadFinalizer
 				ServicePublisher *service_publisher,
 				ServiceBrowser *service_browser,
 				PluginManager *pmanager,
-				tf::Transformer *tf_listener);
+				tf::Transformer *tf_listener,
+				SyncPointManager *syncpoint_manager);
 
  private:
   std::map<std::string, AspectIniFin *> __inifins;
diff --git a/src/libs/aspect/syncpoint.cpp b/src/libs/aspect/syncpoint.cpp
new file mode 100644
index 000000000..02d5ccc76
--- /dev/null
+++ b/src/libs/aspect/syncpoint.cpp
@@ -0,0 +1,144 @@
+/***************************************************************************
+ *  syncpoint.cpp - SyncPoint Aspect
+ *
+ *  Created: Thu Feb 19 14:31:42 2015
+ *  Copyright  2015  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <aspect/syncpoint.h>
+
+#include <core/threading/thread.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointAspect <aspect/syncpoint_manager.h>
+ * Thread aspect to acces to SyncPoints
+ * Give this aspect to your thread to manage SyncPoints,
+ * i.e. wait for SyncPoints and emit SyncPoints
+ * @ingroup Aspects
+ * @author Till Hofmann
+ */
+
+/** Constructor.
+ * Use this constructor if there should be an input syncpoint. The input syncpoint
+ * will be waited for before every loop.
+ * @param type_in type of the input syncpoint
+ * @param identifier_in identifier of the input syncpoint
+ * @param identifier_out identifier of the output syncpoint.
+ *          If this identifier is empty, no output syncpoint will be used.
+ */
+SyncPointAspect::SyncPointAspect(SyncPoint::WakeupType type_in, std::string identifier_in,
+    std::string identifier_out /* = "" */)
+  : type_in_(type_in), identifier_in_(identifier_in),
+    identifier_out_(identifier_out), sp_in_(NULL), sp_out_(NULL)
+{
+  add_aspect("SyncPointAspect");
+  has_input_syncpoint_ = (identifier_in != "");
+  has_output_syncpoint_ = (identifier_out != "");
+}
+
+/** Constructor.
+ * Use this constructor if there should be no input syncpoint, but only an output
+ * syncpoint.
+ * @param identifier_out identifier of the output syncpoint
+ */
+SyncPointAspect::SyncPointAspect(std::string identifier_out)
+  : type_in_(SyncPoint::NONE), identifier_in_(""),
+    identifier_out_(identifier_out), sp_in_(NULL), sp_out_(NULL)
+{
+  add_aspect("SyncPointAspect");
+  has_input_syncpoint_ = false;
+  has_output_syncpoint_ = true;
+}
+
+/** Destructor */
+SyncPointAspect::~SyncPointAspect()
+{
+}
+
+/** Init SyncPoint aspect.
+ * This initializes the syncpoints and registers the thread as loop listener.
+ * Additionally, the thread is registered as emitter for the output syncpoint
+ * if an output syncpoint is created.
+ * @param thread thread which uses this aspect
+ * @param manager SyncPointManager to use
+ */
+void
+SyncPointAspect::init_SyncPointAspect(Thread *thread, SyncPointManager *manager)
+{
+  if (has_input_syncpoint_) {
+    sp_in_ = manager->get_syncpoint(thread->name(), identifier_in_);
+  }
+
+  if (has_output_syncpoint_) {
+    sp_out_ = manager->get_syncpoint(thread->name(), identifier_out_);
+    sp_out_->register_emitter(thread->name());
+  }
+
+  if (has_input_syncpoint_ || has_output_syncpoint_) {
+    thread->add_loop_listener(this);
+  }
+}
+
+/** Finalize SyncPoint aspect.
+ * This releases all syncpoints and unregisters the thread as loop listener.
+ * @param thread thread which uses this aspect
+ * @param manager SyncPointManager to use
+ */
+void
+SyncPointAspect::finalize_SyncPointAspect(Thread *thread, SyncPointManager *manager)
+{
+  if (has_input_syncpoint_) {
+    manager->release_syncpoint(thread->name(), sp_in_);
+  }
+
+  if (has_output_syncpoint_) {
+    sp_out_->unregister_emitter(thread->name());
+    manager->release_syncpoint(thread->name(), sp_out_);
+  }
+
+  if (has_input_syncpoint_ || has_output_syncpoint_) {
+    thread->remove_loop_listener(this);
+  }
+}
+
+/** Wait for the input syncpoint before loop()
+ * @param thread thread which uses this aspect and whose loop() will be called
+ */
+void
+SyncPointAspect::pre_loop(Thread *thread)
+{
+  if (has_input_syncpoint_) {
+    sp_in_->wait(thread->name(), type_in_);
+  }
+}
+
+/** Emit the output syncpoint after loop()
+ * @param thread thread which uses this aspect and whose loop() just returned
+ */
+void
+SyncPointAspect::post_loop(Thread *thread)
+{
+  if (has_output_syncpoint_) {
+    sp_out_->emit(thread->name());
+  }
+}
+
+} // end namespace fawkes
diff --git a/src/libs/aspect/syncpoint.h b/src/libs/aspect/syncpoint.h
new file mode 100644
index 000000000..20b00199d
--- /dev/null
+++ b/src/libs/aspect/syncpoint.h
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *  syncpoint.h - SyncPoint Aspect
+ *
+ *  Created: Thu Feb 19 14:31:42 2015
+ *  Copyright  2015  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __ASPECT_SYNCPOINT_H_
+#define __ASPECT_SYNCPOINT_H_
+
+#include <aspect/aspect.h>
+#include <syncpoint/syncpoint.h>
+#include <syncpoint/syncpoint_manager.h>
+#include <core/threading/thread_loop_listener.h>
+
+#include <string>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointAspect : public virtual Aspect, public ThreadLoopListener
+{
+  public:
+    SyncPointAspect(SyncPoint::WakeupType type_in, std::string identifier_in, std::string identifier_out = "");
+    SyncPointAspect(std::string out_identifier);
+    virtual ~SyncPointAspect();
+
+    void init_SyncPointAspect(Thread *thread, SyncPointManager *syncpoint_manager);
+    void finalize_SyncPointAspect(Thread *thread, SyncPointManager *syncpoint_manager);
+
+    void pre_loop(Thread *thread);
+    void post_loop(Thread *thread);
+
+  private:
+    SyncPoint::WakeupType type_in_;
+    std::string identifier_in_;
+    std::string identifier_out_;
+    bool has_input_syncpoint_;
+    bool has_output_syncpoint_;
+    RefPtr<SyncPoint> sp_in_;
+    RefPtr<SyncPoint> sp_out_;
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/aspect/syncpoint_manager.cpp b/src/libs/aspect/syncpoint_manager.cpp
new file mode 100644
index 000000000..dbbfb3f99
--- /dev/null
+++ b/src/libs/aspect/syncpoint_manager.cpp
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *  syncpoint_manager.cpp - SyncPointManager Aspect
+ *
+ *  Created: Thu Jan 09 12:25:13 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <aspect/syncpoint_manager.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointManagerAspect <aspect/syncpoint_manager.h>
+ * Thread aspect to acces to SyncPoints
+ * Give this aspect to your thread to manage SyncPoints,
+ * i.e. wait for SyncPoints and emit SyncPoints
+ * @ingroup Aspects
+ * @author Till Hofmann
+ */
+
+/** @var SyncPoint * SyncPointManagerAspect::syncpoint_manager
+ * This is the SyncPointManager instance you can use to manage syncpoints.
+ */
+
+/** Constructor. */
+SyncPointManagerAspect::SyncPointManagerAspect()
+{
+  add_aspect("SyncPointManagerAspect");
+  syncpoint_manager = 0;
+}
+
+SyncPointManagerAspect::~SyncPointManagerAspect()
+{
+}
+
+/** Init SyncPointManager aspect.
+ * This sets the SyncPointManager that can be used to manage SyncPoints.
+ * @param manager SyncPointManager to use
+ */
+void
+SyncPointManagerAspect::init_SyncPointManagerAspect(SyncPointManager *manager)
+{
+  syncpoint_manager = manager;
+}
+
+} // end namespace fawkes
diff --git a/src/libs/aspect/syncpoint_manager.h b/src/libs/aspect/syncpoint_manager.h
new file mode 100644
index 000000000..a00b9d1cd
--- /dev/null
+++ b/src/libs/aspect/syncpoint_manager.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *  syncpoint_manager.h - SyncPointManager Aspect
+ *
+ *  Created: Thu Jan 09 12:22:10 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __ASPECT_SYNCPOINT_MANAGER_H_
+#define __ASPECT_SYNCPOINT_MANAGER_H_
+
+#include <aspect/aspect.h>
+#include <syncpoint/syncpoint_manager.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointManagerAspect : public virtual Aspect
+{
+  public:
+  SyncPointManagerAspect();
+  virtual ~SyncPointManagerAspect();
+
+  void init_SyncPointManagerAspect(SyncPointManager *syncpoint_manager);
+
+  protected:
+  SyncPointManager *syncpoint_manager;
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/baseapp/Makefile b/src/libs/baseapp/Makefile
index 4b156a7e3..a216dd497 100644
--- a/src/libs/baseapp/Makefile
+++ b/src/libs/baseapp/Makefile
@@ -24,7 +24,8 @@ LDFLAGS += $(LDFLAGS_LIBDAEMON) $(LDFLAGS_TF)
 
 LIBS_libfawkesbaseapp = stdc++ pthread fawkescore fawkesutils fawkesconfig \
 			fawkesblackboard fawkesplugin fawkesnetcomm \
-			fawkesaspects fawkeslogging fawkesnetworklogger
+			fawkesaspects fawkeslogging fawkesnetworklogger \
+			fawkessyncpoint \
 
 REQ_BOOST_LIBS = asio system
 HAVE_BOOST_LIBS = $(call boost-have-libs,$(REQ_BOOST_LIBS))
diff --git a/src/libs/baseapp/main_thread.cpp b/src/libs/baseapp/main_thread.cpp
index 6cbef6a1b..a2c1a5f12 100644
--- a/src/libs/baseapp/main_thread.cpp
+++ b/src/libs/baseapp/main_thread.cpp
@@ -65,6 +65,7 @@ namespace fawkes {
  * @param multi_logger basic multi logger to use, a network logger will be
  * added in the ctor.
  * @param thread_manager thread manager used to wakeup threads
+ * @param syncpoint_manager syncpoint manager used to manage syncpoints
  * @param plugin_manager plugin manager to load the desired plugins
  * @param load_plugins string with comma-separated list of names of plugins
  * to load on startup.
@@ -73,6 +74,7 @@ namespace fawkes {
 FawkesMainThread::FawkesMainThread(Configuration *config,
 				   MultiLogger *multi_logger,
 				   ThreadManager *thread_manager,
+				   SyncPointManager *syncpoint_manager,
 				   PluginManager *plugin_manager,
 				   const char *load_plugins,
                                    const char *default_plugin)
@@ -80,6 +82,7 @@ FawkesMainThread::FawkesMainThread(Configuration *config,
 {
   __plugin_manager    = plugin_manager;
   __thread_manager    = thread_manager;
+  __syncpoint_manager = syncpoint_manager;
   __multi_logger      = multi_logger;
   __config            = config;
 
@@ -208,6 +211,36 @@ FawkesMainThread::full_start()
 void
 FawkesMainThread::once()
 {
+  // register to all syncpoints of the main loop
+  std::vector<BlockedTimingAspect::WakeupHook> hooks;
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_PRE_LOOP);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PREPARE);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_WORLDSTATE);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_THINK);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_SKILL);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_ACT);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_ACT_EXEC);
+  hooks.push_back(BlockedTimingAspect::WAKEUP_HOOK_POST_LOOP);
+
+  try {
+    for (std::vector<BlockedTimingAspect::WakeupHook>::const_iterator it =
+        hooks.begin(); it != hooks.end(); it++) {
+      __syncpoints_start_hook.push_back(
+        __syncpoint_manager->get_syncpoint("FawkesMainThread",
+          BlockedTimingAspect::blocked_timing_hook_to_start_syncpoint(*it)));
+      __syncpoints_start_hook.back()->register_emitter("FawkesMainThread");
+      __syncpoints_end_hook.push_back(
+        __syncpoint_manager->get_syncpoint("FawkesMainThread",
+          BlockedTimingAspect::blocked_timing_hook_to_end_syncpoint(*it)));
+    }
+  } catch (Exception &e) {
+    __multi_logger->log_error("FawkesMainThread",
+      "Failed to acquire mainloop syncpoint");
+    throw;
+  }
+
   // if plugins passed on command line or in init options, load!
   if ( __load_plugins) {
     try {
@@ -306,16 +339,17 @@ FawkesMainThread::loop()
 	__multi_logger->log_warn("FawkesMainThread", e);
       }
     } else {
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_PRE_LOOP,       __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE, __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PREPARE, __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS, __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_WORLDSTATE,     __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_THINK,          __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_SKILL,          __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_ACT,            __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_ACT_EXEC,       __max_thread_time_usec);
-      safe_wake(BlockedTimingAspect::WAKEUP_HOOK_POST_LOOP,      __max_thread_time_usec);
+      uint num_hooks = __syncpoints_start_hook.size();
+      if (__syncpoints_end_hook.size() != num_hooks) {
+        __multi_logger->log_error("FawkesMainThread",
+          "Hook syncpoints are not initialized properly, not waking up any threads!");
+      } else {
+        for (uint i = 0; i < num_hooks; i++) {
+          __syncpoints_start_hook[i]->emit("FawkesMainThread");
+          __syncpoints_end_hook[i]->reltime_wait_for_all("FawkesMainThread",
+              0, __max_thread_time_nanosec);
+        }
+      }
     }
     __mainloop_mutex->unlock();
     set_cancel_state(old_state);
diff --git a/src/libs/baseapp/main_thread.h b/src/libs/baseapp/main_thread.h
index d4d6eafbd..c0d65432c 100644
--- a/src/libs/baseapp/main_thread.h
+++ b/src/libs/baseapp/main_thread.h
@@ -24,6 +24,7 @@
 #ifndef __LIBS_BASEAPP_MAIN_THREAD_H_
 #define __LIBS_BASEAPP_MAIN_THREAD_H_
 
+#include <syncpoint/syncpoint_manager.h>
 #include <baseapp/thread_manager.h>
 #include <core/threading/thread.h>
 #include <aspect/mainloop/employer.h>
@@ -33,6 +34,7 @@
 
 #include <list>
 #include <string>
+#include <vector>
 #include <getopt.h>
 
 namespace fawkes {
@@ -53,6 +55,7 @@ class InterruptibleBarrier;
 class Barrier;
 class Mutex;
 class ThreadManager;
+class SyncPointManager;
 class FawkesNetworkManager;
 
 class FawkesMainThread
@@ -63,6 +66,7 @@ class FawkesMainThread
   FawkesMainThread(Configuration *config,
 		   MultiLogger *multi_logger,
 		   ThreadManager *thread_manager,
+		   SyncPointManager *syncpoint_manager,
 		   PluginManager *plugin_manager,
 		   const char *load_plugins,
                    const char *default_plugin = 0);
@@ -128,6 +132,7 @@ class FawkesMainThread
   char                 *__load_plugins;
 
   ThreadManager        *__thread_manager;
+  SyncPointManager     *__syncpoint_manager;
   PluginManager        *__plugin_manager;
 
   std::list<std::string>        __recovered_threads;
@@ -139,6 +144,9 @@ class FawkesMainThread
   Time                         *__loop_end;
   bool                          __enable_looptime_warnings;
 
+  std::vector<RefPtr<SyncPoint> > __syncpoints_start_hook;
+  std::vector<RefPtr<SyncPoint> > __syncpoints_end_hook;
+
 };
 
 } // end namespace fawkes
diff --git a/src/libs/baseapp/run.cpp b/src/libs/baseapp/run.cpp
index 0bac82d64..12cb36e45 100644
--- a/src/libs/baseapp/run.cpp
+++ b/src/libs/baseapp/run.cpp
@@ -48,6 +48,7 @@
 #include <plugin/manager.h>
 #include <plugin/net/handler.h>
 #include <aspect/manager.h>
+#include <syncpoint/syncpoint_manager.h>
 #ifdef HAVE_TF
 #  include <tf/transform_listener.h>
 #  include <tf/transformer.h>
@@ -89,6 +90,7 @@ InitOptions               * init_options = NULL;
 tf::Transformer           * tf_transformer = NULL;
 tf::TransformListener     * tf_listener = NULL;
 Time                      * start_time = NULL;
+SyncPointManager          * syncpoint_manager = NULL;
 #ifdef HAVE_LOGGING_FD_REDIRECT
 LogFileDescriptorToLog    * log_fd_redirect_stderr_ = NULL;
 LogFileDescriptorToLog    * log_fd_redirect_stdout_ = NULL;
@@ -385,6 +387,8 @@ init(InitOptions options, int & retval)
   aspect_manager     = new AspectManager();
   thread_manager     = new ThreadManager(aspect_manager, aspect_manager);
 
+  syncpoint_manager  = new SyncPointManager(logger);
+
   plugin_manager     = new PluginManager(thread_manager, config,
 					 "/fawkes/meta_plugins/",
 					 options.plugin_module_flags(),
@@ -414,6 +418,7 @@ init(InitOptions options, int & retval)
   // *** Create main thread, but do not start, yet
   main_thread = new fawkes::FawkesMainThread(config, logger,
 					     thread_manager,
+					     syncpoint_manager,
 					     plugin_manager,
 					     options.load_plugin_list(),
                                              options.default_plugin());
@@ -427,7 +432,8 @@ init(InitOptions options, int & retval)
 					   network_manager->nnresolver(),
 					   network_manager->service_publisher(),
 					   network_manager->service_browser(),
-					   plugin_manager, tf_transformer);
+					   plugin_manager, tf_transformer,
+					   syncpoint_manager);
 
   retval = 0;
   return true;
diff --git a/src/libs/baseapp/timing_thread.cpp b/src/libs/baseapp/timing_thread.cpp
new file mode 100644
index 000000000..5d96fe669
--- /dev/null
+++ b/src/libs/baseapp/timing_thread.cpp
@@ -0,0 +1,143 @@
+/***************************************************************************
+ *  timing_thread.cpp - Timing thread to achieve a desired main loop time
+ *
+ *  Created: Thu Jul 23 14:45:42 2015
+ *  Copyright  2015-2017  Till Hofmann
+ ****************************************************************************/
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+
+#include <baseapp/timing_thread.h>
+
+#include <unistd.h>
+
+
+#define CFG_PREFIX "/fawkes/mainapp/"
+
+namespace fawkes {
+
+/** @class FawkesTimingThread <baseapp/timing_thread.h>
+ * Thread to control the main loop timing.
+ * This thread uses the preloop and postloop SyncPoints to control the timing of
+ * the main loop. It waits for the preloop SyncPoint at the beginning of the
+ * main loop and emits the postloop SyncPoint at the end of the loop. If the
+ * loop time is less than the desired loop time, the thread waits before
+ * releasing the postloop SyncPoint. If the loop time is longer than the maximum
+ * loop time, a warning is printed.
+ */
+FawkesTimingThread::FawkesTimingThread()
+: Thread("FawkesTimingThread", Thread::OPMODE_CONTINUOUS)
+//  ConfigurationChangeHandler(CFG_PREFIX)
+{
+}
+
+/** Initialize.
+ * Get the pre- and postloop SyncPoints and read all relevant config values.
+ */
+void
+FawkesTimingThread::init()
+{
+  __clock = Clock::instance();
+  __loop_start = new Time(__clock);
+  __loop_end = new Time(__clock);
+
+  __syncpoint_loop_start = syncpoint_manager->get_syncpoint(name(),
+      "/preloop/start");
+  __syncpoint_loop_end = syncpoint_manager->get_syncpoint(name(),
+      "/postloop/end");
+
+  try {
+    __desired_loop_time_usec =
+        config->get_uint("/fawkes/mainapp/desired_loop_time");
+  } catch (Exception &e) {
+    __desired_loop_time_usec = 0;
+    logger->log_info(name(), "Desired loop time not set, assuming 0");
+  }
+  __desired_loop_time_sec  = (float)__desired_loop_time_usec / 1000000.f;
+
+  try {
+    __min_loop_time_usec =
+        config->get_uint("/fawkes/mainapp/min_loop_time");
+  } catch (Exception &e) {
+    __min_loop_time_usec = 0;
+    logger->log_info(name(), "Minimal loop time not set, assuming 0");
+  }
+  __min_loop_time_sec  = (float)__min_loop_time_usec / 1000000.f;
+
+  try {
+    __enable_looptime_warnings =
+      config->get_bool("/fawkes/mainapp/enable_looptime_warnings");
+    if(!__enable_looptime_warnings) {
+      logger->log_debug(name(), "loop time warnings are disabled");
+    }
+  } catch(Exception &e) {
+    __enable_looptime_warnings = true;
+  }
+
+}
+
+/** Thread loop.
+ * This loop runs parallel to the main loop. At the beginning of the main loop,
+ * it waits for the preloop SyncPoint. At the end of the main loop, it emits the
+ * postloop SyncPoint.
+ */
+void
+FawkesTimingThread::loop()
+{
+  __syncpoint_loop_start->wait(name());
+  __loop_start->stamp_systime();
+
+  __syncpoint_loop_end->wait(name());
+  __loop_end->stamp_systime();
+  float loop_time = *__loop_end - __loop_start;
+
+  if (loop_time < __min_loop_time_usec) {
+    logger->log_warn(name(), "Minimal loop time not reached, extending loop");
+    usleep(__min_loop_time_usec - loop_time);
+    __loop_end->stamp_systime();
+    loop_time = *__loop_end - __loop_start;
+  }
+
+  if (__desired_loop_time_sec > 0) {
+    if(__enable_looptime_warnings) {
+      // give some extra 10% to eliminate frequent false warnings due to regular
+      // time jitter (TimeWait might not be all that precise)
+      if (loop_time > 1.1 * __desired_loop_time_sec) {
+        logger->log_warn(name(), "Loop time exceeded, "
+            "desired: %f sec (%u usec),  actual: %f sec",
+            __desired_loop_time_sec, __desired_loop_time_usec,
+            loop_time);
+      } else {
+        logger->log_warn(name(), "Desired loop time achieved, "
+            "desired: %f sec (%u usec),  actual: %f sec",
+            __desired_loop_time_sec, __desired_loop_time_usec,
+            loop_time);
+      }
+    }
+  }
+}
+
+/** Finalize the thread.
+ * Release all SyncPoints and do other cleanup.
+ */
+void
+FawkesTimingThread::finalize()
+{
+  syncpoint_manager->release_syncpoint(name(), __syncpoint_loop_start);
+  syncpoint_manager->release_syncpoint(name(), __syncpoint_loop_end);
+  delete __loop_start;
+  delete __loop_end;
+}
+
+} // end namespace fawkes
diff --git a/src/libs/baseapp/timing_thread.h b/src/libs/baseapp/timing_thread.h
new file mode 100644
index 000000000..89a58ace8
--- /dev/null
+++ b/src/libs/baseapp/timing_thread.h
@@ -0,0 +1,70 @@
+/***************************************************************************
+ *  timing_thread.h - Timing thread to achieve a desired main loop time
+ *
+ *  Created: Thu Jul 23 14:45:42 2015
+ *  Copyright  2015-2017  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+
+#ifndef __LIBS_BASEAPP_TIMING_THREAD_H_
+#define __LIBS_BASEAPP_TIMING_THREAD_H_
+
+#include <core/threading/thread.h>
+#include <aspect/syncpoint_manager.h>
+#include <aspect/logging.h>
+#include <aspect/configurable.h>
+
+#include <utils/time/clock.h>
+
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class FawkesTimingThread
+: public Thread,
+  public SyncPointManagerAspect,
+  public ConfigurableAspect,
+//  public ConfigurationChangeHandler,
+  public LoggingAspect
+{
+  public:
+    FawkesTimingThread();
+
+    virtual void init();
+    virtual void loop();
+    virtual void finalize();
+
+  private:
+    Clock *__clock;
+    Time *__loop_start;
+    Time *__loop_end;
+    float __desired_loop_time_sec;
+    uint __desired_loop_time_usec;
+    float __min_loop_time_sec;
+    uint __min_loop_time_usec;
+    bool __enable_looptime_warnings;
+
+    RefPtr<SyncPoint> __syncpoint_loop_start;
+    RefPtr<SyncPoint> __syncpoint_loop_end;
+};
+
+
+} // namespace fawkes
+
+#endif // __LIBS_BASEAPP_TIMING_THREAD_H_
diff --git a/src/libs/config/yaml.cpp b/src/libs/config/yaml.cpp
index c064ca534..303371c7e 100644
--- a/src/libs/config/yaml.cpp
+++ b/src/libs/config/yaml.cpp
@@ -1166,6 +1166,7 @@ YamlConfiguration::set_float(const char *path, float f)
   root_->set_value(path, f);
   host_root_->set_value(path, f);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1174,6 +1175,7 @@ YamlConfiguration::set_uint(const char *path, unsigned int uint)
   root_->set_value(path, uint);
   host_root_->set_value(path, uint);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1182,6 +1184,7 @@ YamlConfiguration::set_int(const char *path, int i)
   root_->set_value(path, i);
   host_root_->set_value(path, i);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1190,6 +1193,7 @@ YamlConfiguration::set_bool(const char *path, bool b)
   root_->set_value(path, b);
   host_root_->set_value(path, b);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1198,6 +1202,7 @@ YamlConfiguration::set_string(const char *path, const char *s)
   root_->set_value(path, std::string(s));
   host_root_->set_value(path, std::string(s));
   write_host_file();
+  notify_handlers(path, false);
 }
 
 
@@ -1213,6 +1218,7 @@ YamlConfiguration::set_floats(const char *path, std::vector<float> &f)
   root_->set_list(path, f);
   host_root_->set_list(path, f);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1221,6 +1227,7 @@ YamlConfiguration::set_uints(const char *path, std::vector<unsigned int> &u)
   root_->set_list(path, u);
   host_root_->set_list(path, u);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1229,6 +1236,7 @@ YamlConfiguration::set_ints(const char *path, std::vector<int> &i)
   root_->set_list(path, i);
   host_root_->set_list(path, i);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1237,6 +1245,7 @@ YamlConfiguration::set_bools(const char *path, std::vector<bool> &b)
   root_->set_list(path, b);
   host_root_->set_list(path, b);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1245,6 +1254,7 @@ YamlConfiguration::set_strings(const char *path, std::vector<std::string> &s)
   root_->set_list(path, s);
   host_root_->set_list(path, s);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
@@ -1253,6 +1263,7 @@ YamlConfiguration::set_strings(const char *path, std::vector<const char *> &s)
   root_->set_list(path, s);
   host_root_->set_list(path, s);
   write_host_file();
+  notify_handlers(path, false);
 }
 
 void
diff --git a/src/libs/core/threading/thread.cpp b/src/libs/core/threading/thread.cpp
index fbc39642f..950ebf3ae 100644
--- a/src/libs/core/threading/thread.cpp
+++ b/src/libs/core/threading/thread.cpp
@@ -29,6 +29,8 @@
 #include <core/threading/read_write_lock.h>
 #include <core/threading/thread_finalizer.h>
 #include <core/threading/thread_notification_listener.h>
+#include <core/threading/thread_loop_listener.h>
+
 #include <core/exceptions/software.h>
 #include <core/exceptions/system.h>
 #include <core/utils/lock_list.h>
@@ -250,6 +252,7 @@ Thread::__constructor(const char *name, OpMode op_mode)
   __op_mode = op_mode;
   __name   = strdup(name);
   __notification_listeners = new LockList<ThreadNotificationListener *>();
+  __loop_listeners         = new LockList<ThreadLoopListener *>();
 
   if ( __op_mode == OPMODE_WAITFORWAKEUP ) {
     __sleep_mutex        = new Mutex();
@@ -295,6 +298,7 @@ Thread::~Thread()
   delete loop_mutex;
   free(__name);
   delete __notification_listeners;
+  delete __loop_listeners;
   delete loopinterrupt_antistarve_mutex;
   delete __startup_barrier;
   delete __prepfin_hold_mutex;
@@ -628,6 +632,16 @@ Thread::join()
     // mutex above could happen!
     loop_mutex->try_lock();
     loop_mutex->unlock();
+
+    // Force unlock of the loop listeners' mutex. If the thread is canceled
+    // during a loop listener call (pre_loop or post_loop), the thread cannot
+    // be finalized because this LockList is still locked, and any aspect using
+    // a LoopListener will try to remove itself from the LockList during
+    // finalization, leading to a deadlock. It is safe to unlock the mutex
+    // because the thread is already joined and thus no more loop listener calls
+    // will occur.
+    __loop_listeners->try_lock();
+    __loop_listeners->unlock();
   }
 }
 
@@ -953,12 +967,30 @@ Thread::run()
 
     loopinterrupt_antistarve_mutex->stopby();
 
-    loop_mutex->lock();
+
     if ( ! finalize_prepared ) {
       __loop_done = false;
+
+      __loop_listeners->lock();
+      for (LockList<ThreadLoopListener *>::iterator it = __loop_listeners->begin();
+          it != __loop_listeners->end();
+          it++) {
+        (*it)->pre_loop(this);
+      }
+      __loop_listeners->unlock();
+
+      loop_mutex->lock();
       loop();
+      loop_mutex->unlock();
+
+      __loop_listeners->lock();
+      for (LockList<ThreadLoopListener *>::reverse_iterator it = __loop_listeners->rbegin();
+          it != __loop_listeners->rend();
+          it++) {
+        (*it)->post_loop(this);
+      }
+      __loop_listeners->unlock();
     }
-    loop_mutex->unlock();
 
     __loop_done_mutex->lock();
     __loop_done = true;
@@ -1183,6 +1215,27 @@ Thread::remove_notification_listener(ThreadNotificationListener *notification_li
 }
 
 
+/** Add loop listener.
+ * Add a loop listener for this thread.
+ * @param loop_listener loop listener to add
+ */
+void
+Thread::add_loop_listener(ThreadLoopListener *loop_listener)
+{
+  __loop_listeners->push_back_locked(loop_listener);
+}
+
+
+/** Remove loop listener.
+ * @param loop_listener loop listener to remove
+ */
+void
+Thread::remove_loop_listener(ThreadLoopListener *loop_listener)
+{
+  __loop_listeners->remove_locked(loop_listener);
+}
+
+
 /** Notify of successful startup.
  * This method is called internally in entry().
  */
diff --git a/src/libs/core/threading/thread.h b/src/libs/core/threading/thread.h
index 7ea9a1b31..02fb8861c 100644
--- a/src/libs/core/threading/thread.h
+++ b/src/libs/core/threading/thread.h
@@ -36,6 +36,7 @@ class WaitCondition;
 class Mutex;
 class Barrier;
 class ThreadNotificationListener;
+class ThreadLoopListener;
 class ThreadList;
 template <typename Type> class LockList;
 
@@ -116,6 +117,9 @@ class Thread {
 
   void notify_of_failed_init();
 
+  void add_loop_listener(ThreadLoopListener *loop_listener);
+  void remove_loop_listener(ThreadLoopListener *loop_listener);
+
  protected:
   Thread(const char *name);
   Thread(const char *name, OpMode op_mode);
@@ -183,6 +187,8 @@ class Thread {
 
   LockList<ThreadNotificationListener *>  *__notification_listeners;
 
+  LockList<ThreadLoopListener *> *__loop_listeners;
+
   static pthread_key_t   THREAD_KEY;
   static pthread_key_t   MAIN_THREAD_KEY;
   static pthread_mutex_t __thread_key_mutex;
diff --git a/src/libs/core/threading/thread_loop_listener.cpp b/src/libs/core/threading/thread_loop_listener.cpp
new file mode 100644
index 000000000..6be93e220
--- /dev/null
+++ b/src/libs/core/threading/thread_loop_listener.cpp
@@ -0,0 +1,70 @@
+
+/***************************************************************************
+ *  thread_loop_listener.cpp - thread notification listener interface
+ *
+ *  Created: Thu Feb 19 13:50:42 2015
+ *  Copyright  2015 Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version. A runtime exception applies to
+ *  this software (see LICENSE.GPL_WRE file mentioned below for details).
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
+ */
+
+#include <core/threading/thread_loop_listener.h>
+
+namespace fawkes {
+
+/** @class ThreadLoopListener <core/threading/thread_loop_listener.h>
+ * Thread loop listener interface.
+ * A thread loop listener can be added to a thread to define pre and post loop
+ * tasks, which are executed before and after every loop.
+ *
+ * @author Till Hofmann
+ *
+ * @fn void ThreadLoopListener::pre_loop(Thread thread*)
+ * This is called by the thread every time before loop() is called.
+ * @param thread thread whose loop() is will be called.
+ *
+ * @fn void ThreadLoopListener::post_loop(Thread thread*)
+ * This is called by the thread every time after loop() returned.
+ * @param thread thread whose loop() just returned.
+ */
+
+/** Virtual empty destructor. */
+ThreadLoopListener::~ThreadLoopListener()
+{
+}
+
+/** Empty stub for the pre loop function of the loop listener.
+ * This function is called right before the loop of the thread with the aspect.
+ * Provide a stub such that not every derived class must implement the function.
+ * @param thread thread this loop listener belongs to
+ */
+void
+ThreadLoopListener::pre_loop(Thread *thread)
+{
+}
+
+/** Empty stub for the post loop function of the loop listener.
+ * This function is called right after the loop of the thread with the aspect.
+ * Provide a stub such that not every derived class must implement the function.
+ * @param thread thread this loop listener belongs to
+ */
+void
+ThreadLoopListener::post_loop(Thread *thread)
+{
+}
+
+
+} // end namespace fawkes
diff --git a/src/libs/core/threading/thread_loop_listener.h b/src/libs/core/threading/thread_loop_listener.h
new file mode 100644
index 000000000..f145bb7f5
--- /dev/null
+++ b/src/libs/core/threading/thread_loop_listener.h
@@ -0,0 +1,44 @@
+
+/***************************************************************************
+ *  thread_loop_listener.h - thread loop listener interface
+ *
+ *  Created: Thu Feb 19 13:50:42 2015
+ *  Copyright  2015 Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version. A runtime exception applies to
+ *  this software (see LICENSE.GPL_WRE file mentioned below for details).
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
+ */
+
+#ifndef __CORE_THREADING_THREAD_LOOP_LISTENER_H_
+#define __CORE_THREADING_THREAD_LOOP_LISTENER_H_
+
+namespace fawkes {
+
+
+class Thread;
+
+class ThreadLoopListener
+{
+ public:
+  virtual ~ThreadLoopListener();
+
+  virtual void pre_loop(Thread *thread);
+  virtual void post_loop(Thread *thread);
+};
+
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/core/threading/wait_condition.h b/src/libs/core/threading/wait_condition.h
index 2d0ca0909..b69c1d6f6 100644
--- a/src/libs/core/threading/wait_condition.h
+++ b/src/libs/core/threading/wait_condition.h
@@ -29,6 +29,10 @@ namespace fawkes {
 class WaitConditionData;
 class Mutex;
 
+/// @cond INTERNALS
+void cleanup_mutex(void *);
+/// @endcond
+
 class WaitCondition {
  public:
   WaitCondition(Mutex *mutex = 0);
diff --git a/src/libs/interfaces/NavigatorInterface.cpp b/src/libs/interfaces/NavigatorInterface.cpp
index 9ab7d4cb8..1385f862c 100644
--- a/src/libs/interfaces/NavigatorInterface.cpp
+++ b/src/libs/interfaces/NavigatorInterface.cpp
@@ -127,7 +127,7 @@ NavigatorInterface::NavigatorInterface() : Interface()
   add_messageinfo("SetStopAtTargetMessage");
   add_messageinfo("SetOrientationModeMessage");
   add_messageinfo("ResetParametersMessage");
-  unsigned char tmp_hash[] = {0xf6, 0x4a, 0xa, 0xc5, 0xe6, 0x3e, 0xe5, 0xd9, 0x89, 0x53, 0x89, 0xe8, 0xce, 0xef, 0xe0, 0xd9};
+  unsigned char tmp_hash[] = {0x43, 0xfc, 0x3a, 0xa9, 0x15, 0x62, 0x32, 0x4c, 0x34, 0x54, 0x7d, 0xd4, 0xf, 0x20, 0x43, 0xcc};
   set_hash(tmp_hash);
 }
 
@@ -850,6 +850,26 @@ NavigatorInterface::enum_tostring(const char *enumtype, int val) const
  */
 
 
+/** Constructor with initial values.
+ * @param ini_msgid initial value for msgid
+ */
+NavigatorInterface::StopMessage::StopMessage(const uint32_t ini_msgid) : Message("StopMessage")
+{
+  data_size = sizeof(StopMessage_data_t);
+  data_ptr  = malloc(data_size);
+  memset(data_ptr, 0, data_size);
+  data      = (StopMessage_data_t *)data_ptr;
+  data_ts   = (message_data_ts_t *)data_ptr;
+  data->msgid = ini_msgid;
+  enum_map_DriveMode[(int)MovingNotAllowed] = "MovingNotAllowed";
+  enum_map_DriveMode[(int)Forward] = "Forward";
+  enum_map_DriveMode[(int)AllowBackward] = "AllowBackward";
+  enum_map_DriveMode[(int)Backward] = "Backward";
+  enum_map_DriveMode[(int)ESCAPE] = "ESCAPE";
+  enum_map_OrientationMode[(int)OrientAtTarget] = "OrientAtTarget";
+  enum_map_OrientationMode[(int)OrientDuringTravel] = "OrientDuringTravel";
+  add_fieldinfo(IFT_UINT32, "msgid", 1, &data->msgid);
+}
 /** Constructor */
 NavigatorInterface::StopMessage::StopMessage() : Message("StopMessage")
 {
@@ -865,6 +885,7 @@ NavigatorInterface::StopMessage::StopMessage() : Message("StopMessage")
   enum_map_DriveMode[(int)ESCAPE] = "ESCAPE";
   enum_map_OrientationMode[(int)OrientAtTarget] = "OrientAtTarget";
   enum_map_OrientationMode[(int)OrientDuringTravel] = "OrientDuringTravel";
+  add_fieldinfo(IFT_UINT32, "msgid", 1, &data->msgid);
 }
 
 /** Destructor */
@@ -886,6 +907,52 @@ NavigatorInterface::StopMessage::StopMessage(const StopMessage *m) : Message("St
 }
 
 /* Methods */
+/** Get msgid value.
+ * 
+	    If zero, stops any motion. If non-zero, the component shall only
+	    stop the motion if the currently executed command was received
+	    through a message with that specific ID.
+
+	    Use the specific version whenever possible. It avoids a race
+	    condition if one intstructing component sends a stop, and
+	    another a new drive command at the same time.
+    
+ * @return msgid value
+ */
+uint32_t
+NavigatorInterface::StopMessage::msgid() const
+{
+  return data->msgid;
+}
+
+/** Get maximum length of msgid value.
+ * @return length of msgid value, can be length of the array or number of 
+ * maximum number of characters for a string
+ */
+size_t
+NavigatorInterface::StopMessage::maxlenof_msgid() const
+{
+  return 1;
+}
+
+/** Set msgid value.
+ * 
+	    If zero, stops any motion. If non-zero, the component shall only
+	    stop the motion if the currently executed command was received
+	    through a message with that specific ID.
+
+	    Use the specific version whenever possible. It avoids a race
+	    condition if one intstructing component sends a stop, and
+	    another a new drive command at the same time.
+    
+ * @param new_msgid new msgid value
+ */
+void
+NavigatorInterface::StopMessage::set_msgid(const uint32_t new_msgid)
+{
+  data->msgid = new_msgid;
+}
+
 /** Clone this message.
  * Produces a message of the same type as this message and copies the
  * data to the new message.
diff --git a/src/libs/interfaces/NavigatorInterface.h b/src/libs/interfaces/NavigatorInterface.h
index 4fa8f9718..af75b4c49 100644
--- a/src/libs/interfaces/NavigatorInterface.h
+++ b/src/libs/interfaces/NavigatorInterface.h
@@ -114,6 +114,15 @@ class NavigatorInterface : public Interface
     typedef struct __attribute__((packed)) {
       int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
       int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
+      uint32_t msgid; /**< 
+	    If zero, stops any motion. If non-zero, the component shall only
+	    stop the motion if the currently executed command was received
+	    through a message with that specific ID.
+
+	    Use the specific version whenever possible. It avoids a race
+	    condition if one intstructing component sends a stop, and
+	    another a new drive command at the same time.
+     */
     } StopMessage_data_t;
 
     StopMessage_data_t *data;
@@ -121,11 +130,15 @@ class NavigatorInterface : public Interface
   interface_enum_map_t enum_map_DriveMode;
   interface_enum_map_t enum_map_OrientationMode;
    public:
+    StopMessage(const uint32_t ini_msgid);
     StopMessage();
     ~StopMessage();
 
     StopMessage(const StopMessage *m);
     /* Methods */
+    uint32_t msgid() const;
+    void set_msgid(const uint32_t new_msgid);
+    size_t maxlenof_msgid() const;
     virtual Message * clone() const;
   };
 
diff --git a/src/libs/interfaces/NavigatorInterface.tolua b/src/libs/interfaces/NavigatorInterface.tolua
index a848c383d..9876445b5 100644
--- a/src/libs/interfaces/NavigatorInterface.tolua
+++ b/src/libs/interfaces/NavigatorInterface.tolua
@@ -33,6 +33,7 @@ class NavigatorInterface : public Interface
 
   class StopMessage : public Message
   {
+    StopMessage(unsigned int ini_msgid);
     StopMessage();
     ~StopMessage();
 
@@ -53,6 +54,9 @@ class NavigatorInterface : public Interface
     void              unref();
     unsigned int      refcount();
 
+    unsigned int msgid();
+    void set_msgid(const unsigned int new_msgid);
+    int maxlenof_msgid() const;
   };
 
   class TurnMessage : public Message
diff --git a/src/libs/interfaces/NavigatorInterface.xml b/src/libs/interfaces/NavigatorInterface.xml
index c749faec8..044900bee 100644
--- a/src/libs/interfaces/NavigatorInterface.xml
+++ b/src/libs/interfaces/NavigatorInterface.xml
@@ -107,6 +107,15 @@
   </data>
   <message name="Stop">
     <comment>Stop motion immediately.</comment>
+    <field type="uint32" name="msgid">
+	    If zero, stops any motion. If non-zero, the component shall only
+	    stop the motion if the currently executed command was received
+	    through a message with that specific ID.
+
+	    Use the specific version whenever possible. It avoids a race
+	    condition if one intstructing component sends a stop, and
+	    another a new drive command at the same time.
+    </field>
   </message>
   <message name="Turn">
     <comment>Turn around own major axis. Opposed to setting a goto with a target
diff --git a/src/libs/kdl_parser/kdl_parser.h b/src/libs/kdl_parser/kdl_parser.h
index 092a55a43..4bd22e6ed 100644
--- a/src/libs/kdl_parser/kdl_parser.h
+++ b/src/libs/kdl_parser/kdl_parser.h
@@ -60,9 +60,8 @@
 #include <string>
 #include <urdf_model/model.h>
 #include <tinyxml.h>
-#include <ros/common.h>
 
-#if !ROS_VERSION_MINIMUM(1, 12, 0)
+#if !defined(HAVE_URDFDOM_TYPES_H)
 namespace urdf {
 typedef boost::shared_ptr<urdf::Joint> JointSharedPtr;
 typedef boost::shared_ptr<urdf::Inertial> InertialSharedPtr;
diff --git a/src/libs/kdl_parser/kdl_parser.mk b/src/libs/kdl_parser/kdl_parser.mk
index baf72bb03..311d3e044 100644
--- a/src/libs/kdl_parser/kdl_parser.mk
+++ b/src/libs/kdl_parser/kdl_parser.mk
@@ -29,7 +29,7 @@ endif
 HAVE_URDFDOMHEADERS=$(if $(shell $(PKGCONFIG) --exists 'urdfdom_headers'; echo $${?/1/}),1,0)
 HAVE_URDFDOM=$(if $(shell $(PKGCONFIG) --exists 'urdfdom'; echo $${?/1/}),1,0)
 HAVE_TINYXML=$(if $(wildcard $(SYSROOT)/usr/include/tinyxml.h),1,0)
-
+HAVE_URDFDOM_TYPES_H=$(if $(shell $(PKGCONFIG) --atleast-version 0.4.0 'urdfdom_headers'; echo $${?/1/}),1,0)
 
 ifeq ($(HAVE_KDL),1)
   ifeq ($(HAVE_URDFDOMHEADERS),1)
@@ -43,6 +43,9 @@ ifeq ($(HAVE_KDL),1)
           $(shell $(PKGCONFIG) --libs 'urdfdom') \
           -ltinyxml
         HAVE_KDLPARSER=1
+        ifeq ($(HAVE_URDFDOM_TYPES_H),1)
+          CFLAGS_KDLPARSER += -DHAVE_URDFDOM_TYPES_H
+        endif
       endif
     endif
   endif
diff --git a/src/libs/kdl_parser/model.h b/src/libs/kdl_parser/model.h
index b0bc9e824..6b00c5c90 100644
--- a/src/libs/kdl_parser/model.h
+++ b/src/libs/kdl_parser/model.h
@@ -60,9 +60,8 @@
 #include <map>
 #include <urdf_model/model.h>
 #include <tinyxml.h>
-#include <ros/common.h>
 
-#if !ROS_VERSION_MINIMUM(1, 12, 0)
+#if !defined(HAVE_URDFDOM_TYPES_H)
 namespace urdf {
 typedef boost::shared_ptr<urdf::ModelInterface> ModelInterfaceSharedPtr;
 }
diff --git a/src/libs/syncpoint/Makefile b/src/libs/syncpoint/Makefile
new file mode 100644
index 000000000..154a448ff
--- /dev/null
+++ b/src/libs/syncpoint/Makefile
@@ -0,0 +1,35 @@
+#*****************************************************************************
+#               Makefile Build System for Fawkes: SyncPoint
+#                            -------------------
+#   Created on Thu Jan 23 15:17:42 2014
+#   Copyright (C) 2014 by Till Hofmann
+#
+#*****************************************************************************
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#*****************************************************************************
+
+BASEDIR = ../../..
+include $(BASEDIR)/etc/buildsys/config.mk
+
+
+LIBS_libfawkessyncpoint = fawkescore fawkesutils
+OBJS_libfawkessyncpoint = $(patsubst %.cpp,%.o,$(patsubst qa/%,,$(subst $(SRCDIR)/,,$(realpath $(wildcard $(SRCDIR)/*.cpp)))))
+HDRS_libfawkessyncpoint = $(subst $(SRCDIR)/,,$(wildcard $(SRCDIR)/*.h))
+
+#CFLAGS += $(CFLAGS_LUA)
+#LDFLAGS_libfawkessyncpoint += $(LDFLAGS_LUA)
+
+OBJS_all = $(OBJS_libfawkessyncpoint)
+
+LIBS_all = $(LIBDIR)/libfawkessyncpoint.so
+
+ifeq ($(OBJSSUBMAKE),1)
+all: $(WARN_TARGETS)
+endif
+
+include $(BUILDSYSDIR)/base.mk
diff --git a/src/libs/syncpoint/exceptions.h b/src/libs/syncpoint/exceptions.h
new file mode 100644
index 000000000..269ebbf7f
--- /dev/null
+++ b/src/libs/syncpoint/exceptions.h
@@ -0,0 +1,225 @@
+/***************************************************************************
+ *  exceptions.h - SyncPoint exceptions
+ *
+ *  Created: Wed Jan 15 11:09:55 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __SYNCPOINT_EXCEPTIONS_H_
+#define __SYNCPOINT_EXCEPTIONS_H_
+
+#include <core/exception.h>
+
+namespace fawkes {
+
+/** A component which is watching a SyncPoint, called get_syncpoint() for the
+ * same identifier
+ */
+class SyncPointAlreadyOpenedException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointAlreadyOpenedException(const char * component,
+      const char *identifier)
+    {
+      append(
+          "Component '%s' called get_syncpoint() for identifier '%s', but is already watching",
+          component, identifier);
+    }
+};
+
+/** Emit was called by a component which isn't in the watcher set
+ * (or wrong component argument was passed)
+ */
+class SyncPointNonWatcherCalledEmitException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointNonWatcherCalledEmitException(const char * component,
+      const char *identifier)
+    {
+      append("Component '%s' called emit for SyncPoint '%s', but is not a watcher",
+          component, identifier);
+    }
+};
+
+/** Emit was called by a component which isn't in the watcher set
+ * (or wrong component argument was passed)
+ */
+class SyncPointNonWatcherCalledWaitException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointNonWatcherCalledWaitException(const char * component,
+      const char *identifier)
+    {
+      append("Component '%s' called wait for SyncPoint '%s', but is not a watcher",
+          component, identifier);
+    }
+};
+
+/** Release was called on a non-existing SyncPoint
+ *
+ */
+class SyncPointReleasedDoesNotExistException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointReleasedDoesNotExistException(const char * component,
+      const char * identifier)
+    {
+      append("Component '%s' tried to release non-existing SyncPoint '%s'",
+          component, identifier);
+    }
+};
+
+/** Release was called by a component which isn't a watcher
+ *
+ */
+class SyncPointReleasedByNonWatcherException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointReleasedByNonWatcherException(const char * component,
+      const char * identifier)
+    {
+      append("Component '%s' tried to release SyncPoint '%s' but is not a watcher",
+          component, identifier);
+    }
+};
+
+/** Invalid identifier used (i.e. an empty string)
+ *
+ */
+class SyncPointInvalidIdentifierException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointInvalidIdentifierException(const char * identifier)
+    {
+      append("Tried to construct a SyncPoint with invalid identifier ('%s'). "
+          "Identifier must be a non-empty absolute path (e.g. '/path/to/syncpoint')"
+          " and may not end with '/'",
+          identifier);
+    }
+};
+
+/** Invalid component name used (i.e. an empty string)
+ *
+ */
+class SyncPointInvalidComponentException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointInvalidComponentException(const char * component,
+      const char * identifier)
+    {
+      append("Invalid component name '%s' while accessing SyncPoint '%s'",
+          component, identifier);
+    }
+};
+
+/** A component called wait() but is already waiting
+ *
+ */
+class SyncPointMultipleWaitCallsException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+    SyncPointMultipleWaitCallsException(const char * component,
+      const char * identifier)
+    {
+      append("Component '%s' called wait() on SyncPoint '%s', but is already waiting",
+          component, identifier);
+    }
+};
+
+/** Emit was called on a SyncBarrier but the calling component is not registered
+ *  as emitter
+ */
+class SyncPointNonEmitterCalledEmitException : public Exception
+{
+  public:
+    /** Constructor.
+     * @param component The calling component
+     * @param identifier The identifier of the SyncPoint
+     */
+	SyncPointNonEmitterCalledEmitException(const char * component,
+      const char *identifier)
+    {
+      append("Component '%s' called emit for SyncPoint '%s', "
+          "but is not a registered emitter", component, identifier);
+    }
+};
+
+/** Invalid SyncPoint type.
+ */
+class SyncPointInvalidTypeException : public Exception
+{
+public:
+  /** Constructor. */
+  SyncPointInvalidTypeException()
+  {
+    append("Invalid SyncPoint Wakeup type.");
+  }
+};
+
+/** The component called release but is still registered as emitter. */
+class SyncPointCannotReleaseEmitter : public Exception
+{
+  public:
+  /** Constructor.
+   *  @param component The calling component
+   *  @param identifier The identifier of the SyncPoint
+   */
+SyncPointCannotReleaseEmitter(const char * component,
+    const char * identifier)
+  {
+    append("Component '%s' called emit for SyncPoint '%s', "
+        "but is still registered as emitter", component, identifier);
+  }
+};
+
+
+} // namespace fawkes
+
+
+#endif
diff --git a/src/libs/syncpoint/syncpoint.cpp b/src/libs/syncpoint/syncpoint.cpp
new file mode 100644
index 000000000..188aed5a8
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint.cpp
@@ -0,0 +1,602 @@
+/***************************************************************************
+ *  syncpoint.cpp - Fawkes SyncPoint
+ *
+ *  Created: Thu Jan 09 12:35:57 2014
+ *  Copyright  2014-2017  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <syncpoint/syncpoint.h>
+#include <syncpoint/exceptions.h>
+
+#include <core/threading/mutex_locker.h>
+#include <utils/time/time.h>
+
+#include <string.h>
+
+using namespace std;
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+
+/** @class SyncPoint <syncpoint/syncpoint.h>
+ * The SyncPoint class.
+ * This class is used for dynamic synchronization of threads which depend
+ * on each other, e.g. threads which are part of a processing chain.
+ *
+ * As an example, thread E generates data which is needed by thread W.
+ * Therefore, both threads share a SyncPoint.
+ * Thread W wait()s for the SyncPoint to be emitted.
+ * Once thread E is done, it emit()s the SyncPoint, which wakes up thread W.
+ *
+ * @author Till Hofmann
+ * @see SyncPointManager
+ */
+
+/** Constructor.
+ * @param identifier The identifier of the SyncPoint. This must be in absolute
+ * path style, e.g. '/some/syncpoint'.
+ * @param logger The logger to use for error messages.
+ * @param max_waittime_sec the maximum number of seconds to wait until a timeout
+ * is triggered
+ * @param max_waittime_nsec the maximum number of nanoseconds to wait until a
+ * timeout is triggered
+ */
+SyncPoint::SyncPoint(string identifier, MultiLogger *logger,
+  uint max_waittime_sec /* = 0 */, uint max_waittime_nsec /* = 0 */)
+    : identifier_(identifier),
+      emit_calls_(CircularBuffer<SyncPointCall>(1000)),
+      wait_for_one_calls_(CircularBuffer<SyncPointCall>(1000)),
+      wait_for_all_calls_(CircularBuffer<SyncPointCall>(1000)),
+      creation_time_(Time()),
+      mutex_(new Mutex()),
+      mutex_next_wait_(new Mutex()),
+      mutex_wait_for_one_(new Mutex()),
+      cond_wait_for_one_(new WaitCondition(mutex_wait_for_one_)),
+      mutex_wait_for_all_(new Mutex()),
+      cond_wait_for_all_(new WaitCondition(mutex_wait_for_all_)),
+      wait_for_all_timer_running_(false),
+      max_waittime_sec_(max_waittime_sec),
+      max_waittime_nsec_(max_waittime_nsec),
+      logger_(logger),
+      last_emitter_reset_(Time(0l))
+{
+  if (identifier.empty()) {
+    cleanup();
+    throw SyncPointInvalidIdentifierException(identifier.c_str());
+  }
+  if (identifier.compare(0,1,"/")) {
+    cleanup();
+    throw SyncPointInvalidIdentifierException(identifier.c_str());
+  }
+  // check if last charater is '/'
+  // The identifier may only end in '/' if '/' is the complete identifier.
+  // '/' is allowed, '/some/' is not allowed
+  if (identifier != "/" && !identifier.compare(identifier.size() - 1, 1, "/")) {
+    cleanup();
+    throw SyncPointInvalidIdentifierException(identifier.c_str());
+  }
+}
+
+SyncPoint::~SyncPoint()
+{
+  cleanup();
+}
+
+/**
+ * @return the identifier of the SyncPoint
+ */
+string
+SyncPoint::get_identifier() const {
+  return identifier_;
+}
+
+/** EqualOperator.
+ * Two SyncPoints are considered equal iff they have the same identifier
+ * @param other The other SyncPoint
+ * @return true if the identifiers of the SyncPoints are equal
+ */
+bool
+SyncPoint::operator==(const SyncPoint &other) const
+{
+  return identifier_ == other.get_identifier();
+}
+
+/** EqualOperator.
+ * A SyncPoint is equal to a given string iff the string is equal to the
+ * SyncPoint's identifier.
+ * @param other the string to compare
+ * @return true if the identifier of the SyncPoint matches the given string
+ */
+bool
+SyncPoint::operator==(const string & other) const
+{
+  return identifier_ == other;
+}
+
+/** LessThan Operator.
+ * Compare two SyncPoints using their identifiers.
+ * @param other The other SyncPoint
+ * @return true if strcmp returns a value < 0 for the identifiers
+ */
+bool
+SyncPoint::operator<(const SyncPoint &other) const
+{
+  return identifier_ < other.get_identifier();
+}
+
+/** Wake up all components which are waiting for this SyncPoint
+ * @param component The identifier of the component emitting the SyncPoint
+ */
+void
+SyncPoint::emit(const std::string & component)
+{
+  emit(component, true);
+}
+
+/** Wake up all components which are waiting for this SyncPoint
+ * @param component The identifier of the component emitting the SyncPoint
+ * @param remove_from_pending if set to true, the component will be removed
+ *        from the pending emitters for this syncpoint
+ */
+void
+SyncPoint::emit(const std::string & component, bool remove_from_pending)
+{
+  mutex_next_wait_->stopby();
+  MutexLocker ml(mutex_);
+  if (!watchers_.count(component)) {
+    throw SyncPointNonWatcherCalledEmitException(component.c_str(),
+        get_identifier().c_str());
+  }
+
+  // unlock all wait_for_one waiters
+  watchers_wait_for_one_.clear();
+  mutex_wait_for_one_->lock();
+  cond_wait_for_one_->wake_all();
+  mutex_wait_for_one_->unlock();
+
+
+  if (!emitters_.count(component)) {
+    throw SyncPointNonEmitterCalledEmitException(component.c_str(),
+      get_identifier().c_str());
+  }
+
+  /* 1. remember whether the component was pending; if so, it may be removed
+   *    from the pending components of the predecessor. Otherwise, it should
+   *    not be removed
+   * 2. only erase the component once; it may be registered multiple times
+   */
+  bool pred_remove_from_pending = false;
+  if (remove_from_pending) {
+    multiset<string>::iterator it_pending = pending_emitters_.find(component);
+    if (it_pending != pending_emitters_.end()) {
+      pending_emitters_.erase(it_pending);
+      if (predecessor_) {
+        if (last_emitter_reset_ <= predecessor_->last_emitter_reset_) {
+          pred_remove_from_pending = true;
+        }
+      }
+
+      // unlock all wait_for_all waiters if all pending emitters have emitted
+      if (pending_emitters_.empty()) {
+        watchers_wait_for_all_.clear();
+        mutex_wait_for_all_->lock();
+        cond_wait_for_all_->wake_all();
+        mutex_wait_for_all_->unlock();
+        reset_emitters();
+      }
+    }
+  }
+
+  emit_calls_.push_back(SyncPointCall(component));
+
+  if (predecessor_) {
+    predecessor_->emit(component, pred_remove_from_pending);
+  }
+}
+
+/** Wait until SyncPoint is emitted.
+ * Either wait until a single emitter has emitted the SyncPoint, or wait
+ * until all registered emitters have emitted the SyncPoint.
+ * If wait_sec != 0 or wait_nsec !=0, then only wait for
+ * wait_sec + wait_nsec*10^-9 seconds and set the SyncPoint's maximum waiting
+ * time to the specified time (i.e., on any subsequent wait calls, wait for
+ * the specified time until a timeout is triggered).
+ * If the maximal wait time has been exceeded, a warning is shown and the
+ * SyncPoint is released.
+ * If the WakeupType is WAIT_FOR_ALL, then the time limit is only used if there
+ * is currently no other component waiting in WAIT_FOR_ALL mode. If there is
+ * already a component waiting, that component's wait_time is used to compute
+ * the timeout. This ensures that in case a timeout occurs, all waiting
+ * components in WAIT_FOR_ALL mode are released simultaneously. Components in
+ * WAIT_FOR_ONE mode are treated separately and have their own timeouts.
+ * @param component The identifier of the component waiting for the SyncPoint
+ * @param type the wakeup type. If this is set to WAIT_FOR_ONE, wait returns
+ * when a single emitter has emitted the SyncPoint. If set to WAIT_FOR_ALL, wait
+ * until all registered emitters have emitted the SyncPoint.
+ * @param wait_sec number of seconds to wait for the SyncPoint
+ * @param wait_nsec number of nanoseconds to wait for the SyncPoint
+ * @see SyncPoint::WakeupType
+ */
+void
+SyncPoint::wait(const std::string & component,
+  WakeupType type /* = WAIT_FOR_ONE */, uint wait_sec /* = 0 */,
+  uint wait_nsec /* = 0 */)
+{
+
+  MutexLocker ml(mutex_);
+
+  std::set<std::string> *watchers;
+  WaitCondition *cond;
+  CircularBuffer<SyncPointCall> *calls;
+  Mutex *mutex_cond;
+  bool *timer_running;
+  // set watchers, cond and calls depending of the Wakeup type
+  if (type == WAIT_FOR_ONE) {
+    watchers = &watchers_wait_for_one_;
+    cond = cond_wait_for_one_;
+    mutex_cond = mutex_wait_for_one_;
+    calls = &wait_for_one_calls_;
+    timer_running = NULL;
+  } else if (type == WAIT_FOR_ALL) {
+    watchers = &watchers_wait_for_all_;
+    cond = cond_wait_for_all_;
+    mutex_cond = mutex_wait_for_all_;
+    timer_running = &wait_for_all_timer_running_;
+    calls = &wait_for_all_calls_;
+  } else {
+    throw SyncPointInvalidTypeException();
+  }
+
+  // check if calling component is registered for this SyncPoint
+  if (!watchers_.count(component)) {
+    throw SyncPointNonWatcherCalledWaitException(component.c_str(), get_identifier().c_str());
+  }
+  // check if calling component is not already waiting
+  if (watchers->count(component)) {
+    throw SyncPointMultipleWaitCallsException(component.c_str(), get_identifier().c_str());
+  }
+
+  /* if type == WAIT_FOR_ALL but no emitter has registered, we can
+   * immediately return
+   * if type == WAIT_FOR_ONE, we always wait
+   */
+  bool need_to_wait = !emitters_.empty() || type == WAIT_FOR_ONE;
+  if (need_to_wait) {
+    watchers->insert(component);
+  }
+
+  /* Check if emitters are currently waiting for this component.
+   * If so, wake them up *after* locking the WaitCondition's mutex.
+   * Only this way we can guarantee that this component will certainly call
+   * wait before the emitters emit
+   */
+  Time start;
+  mutex_cond->lock();
+  if (emit_locker_ == component) {
+    mutex_next_wait_->unlock();
+    emit_locker_ = "";
+  }
+  if (need_to_wait) {
+    if (type == WAIT_FOR_ONE) {
+      ml.unlock();
+      bool timeout;
+      pthread_cleanup_push(cleanup_mutex, mutex_cond);
+      timeout = !cond->reltimed_wait(wait_sec, wait_nsec);
+      pthread_cleanup_pop(1);
+      if (timeout) {
+        ml.relock();
+        handle_default(component, type);
+        ml.unlock();
+      }
+    } else {
+      if (*timer_running) {
+        ml.unlock();
+        pthread_cleanup_push(cleanup_mutex, mutex_cond);
+        cond->wait();
+        pthread_cleanup_pop(1);
+      } else {
+        *timer_running = true;
+        if (wait_sec != 0 || wait_nsec != 0) {
+          max_waittime_sec_ = wait_sec;
+          max_waittime_nsec_ = wait_nsec;
+        }
+        ml.unlock();
+        bool timeout;
+        pthread_cleanup_push(cleanup_mutex, mutex_cond);
+        timeout = !cond->reltimed_wait(max_waittime_sec_, max_waittime_nsec_);
+        pthread_cleanup_pop(1);
+        ml.relock();
+        *timer_running = false;
+        if (timeout) {
+          // wait failed, handle default
+          handle_default(component, type);
+          mutex_cond->lock();
+          cond->wake_all();
+          mutex_cond->unlock();
+        }
+        ml.unlock();
+      }
+    }
+  } else {
+    ml.unlock();
+    mutex_cond->unlock();
+  }
+  Time wait_time = Time() - start;
+  ml.relock();
+  calls->push_back(SyncPointCall(component, start, wait_time));
+}
+
+/** Wait for a single emitter.
+ * @param component The identifier of the calling component.
+ */
+void
+SyncPoint::wait_for_one(const string & component)
+{
+  wait(component, WAIT_FOR_ONE);
+}
+
+/** Wait for all registered emitters.
+ * @param component The identifier of the calling component.
+ */
+void
+SyncPoint::wait_for_all(const string & component)
+{
+  wait(component, WAIT_FOR_ALL);
+}
+
+/** Wait for a single emitter for the given time.
+ * @param component The identifier of the calling component.
+ * @param wait_sec number of seconds to wait
+ * @param wait_nsec number of nanoseconds to wait additionally to wait_sec
+ */
+void
+SyncPoint::reltime_wait_for_one(const string & component, uint wait_sec,
+  uint wait_nsec)
+{
+  wait(component, SyncPoint::WAIT_FOR_ONE, wait_sec, wait_nsec);
+}
+
+/** Wait for all registered emitters for the given time.
+ * @param component The identifier of the calling component.
+ * @param wait_sec number of seconds to wait
+ * @param wait_nsec number of nanoseconds to wait additionally to wait_sec
+ */
+void
+SyncPoint::reltime_wait_for_all(const string & component, uint wait_sec,
+  uint wait_nsec)
+{
+  wait(component, SyncPoint::WAIT_FOR_ALL, wait_sec, wait_nsec);
+}
+
+
+/** Lock the SyncPoint for emitters until the specified component does the next
+ *  wait() call. This forces an emitter of this SyncPoint to wait during the
+ *  emit until the waiter calls wait(). This is useful if you want to guarantee
+ *  that the waiter does not call wait() immediately after the emitter has
+ *  called emit().
+ *  @param component the component locking the SyncPoint
+ */
+void
+SyncPoint::lock_until_next_wait(const string & component)
+{
+  MutexLocker ml(mutex_);
+  if (mutex_next_wait_->try_lock()) {
+    emit_locker_ = component;
+  } else {
+    logger_->log_warn("SyncPoints", "%s tried to call lock_until_next_wait, "
+        "but another component already did the same. Ignoring.",
+        component.c_str());
+  }
+}
+
+/** Register an emitter. A thread can only emit the barrier if it has been
+ *  registered.
+ *  @param component The identifier of the registering component.
+ */
+void
+SyncPoint::register_emitter(const string & component)
+{
+  MutexLocker ml(mutex_);
+  emitters_.insert(component);
+  pending_emitters_.insert(component);
+  if (predecessor_) {
+    predecessor_->register_emitter(component);
+  }
+}
+
+/** Unregister an emitter. This removes the component from the syncpoint, thus
+ *  other components will not wait for it anymore.
+ *  @param component The identifier of the component which is unregistered.
+ *  @param emit_if_pending if this is set to true and the component is a
+ *         pending emitter, emit the syncpoint before releasing it.
+ */
+void
+SyncPoint::unregister_emitter(const string & component, bool emit_if_pending) {
+  // TODO should this throw if the calling component is not registered?
+  multiset<string>::iterator it_emitter = emitters_.find(component);
+  if (it_emitter == emitters_.end()) {
+	  // component is not an emitter
+	  return;
+  }
+  MutexLocker ml(mutex_);
+  if (emit_if_pending && is_pending(component)) {
+    ml.unlock();
+    emit(component);
+    ml.relock();
+  }
+
+  // erase a single element from the set of emitters
+  emitters_.erase(it_emitter);
+  if (predecessor_) {
+    // never emit the predecessor if it's pending; it is already emitted above
+    predecessor_->unregister_emitter(component, false);
+  }
+}
+
+/** Check if the given component is an emitter.
+ *  @param component The name of the component.
+ *  @return True iff the given component is an emitter of this syncpoint.
+ */
+bool
+SyncPoint::is_emitter(const string & component) const {
+  MutexLocker ml(mutex_);
+	return emitters_.count(component) > 0;
+}
+
+/** Check if the given component is a watch.
+ *  @param component The name of the component.
+ *  @return True iff the given component is a watcher.
+ */
+bool
+SyncPoint::is_watcher(const string & component) const {
+  MutexLocker ml(mutex_);
+	return watchers_.count(component) > 0;
+}
+
+/** Add a watcher to the watch list
+ *  @param watcher the new watcher
+ *  @return A pair, of which the first element is an iterator that points
+ *           to the possibly inserted element, and the second is a bool
+ *           that is true if the element was actually inserted.
+ */
+pair<set<string>::iterator,bool>
+SyncPoint::add_watcher(string watcher)
+{
+  MutexLocker ml(mutex_);
+  return watchers_.insert(watcher);
+}
+
+/**
+ * @return all watchers of the SyncPoint
+ */
+std::set<std::string>
+SyncPoint::get_watchers() const {
+  MutexLocker ml(mutex_);
+  return watchers_;
+}
+
+/**
+ * @return a copy of the wait call buffer with the given type
+ * @param type the type of the wait call buffer
+ */
+CircularBuffer<SyncPointCall>
+SyncPoint::get_wait_calls(WakeupType type /* = WAIT_FOR_ONE */) const {
+  MutexLocker ml(mutex_);
+  if (type == WAIT_FOR_ONE) {
+    return wait_for_one_calls_;
+  } else if (type == WAIT_FOR_ALL) {
+    return wait_for_all_calls_;
+  } else {
+    throw SyncPointInvalidTypeException();
+  }
+}
+
+/**
+ * @return a copy of the set of registered emitters
+ */
+multiset<string>
+SyncPoint::get_emitters() const
+{
+  return emitters_;
+}
+
+/**
+ * @return a copy of the emit call buffer
+ */
+CircularBuffer<SyncPointCall>
+SyncPoint::get_emit_calls() const {
+  MutexLocker ml(mutex_);
+  return emit_calls_;
+}
+
+/**
+ * Check if the given waiter is currently waiting with the given type
+ * @param watcher the string identifier of the watcher to check
+ * @param type the type of call to check
+ * @return true if the waiter is currently waiting
+ */
+bool
+SyncPoint::watcher_is_waiting(std::string watcher, WakeupType type) const
+{
+  switch (type) {
+    case SyncPoint::WAIT_FOR_ONE:
+      return watchers_wait_for_one_.count(watcher);
+    case SyncPoint::WAIT_FOR_ALL:
+      return watchers_wait_for_all_.count(watcher);
+    default:
+      throw Exception("Unknown watch type %u for syncpoint %s",
+                      type, identifier_);
+  }
+}
+
+void
+SyncPoint::reset_emitters() {
+  last_emitter_reset_ = Time();
+  pending_emitters_ = emitters_;
+}
+
+bool
+SyncPoint::is_pending(string component) {
+  return pending_emitters_.count(component) > 0;
+}
+
+void
+SyncPoint::handle_default(string component, WakeupType type)
+{
+  logger_->log_warn(component.c_str(),
+      "Thread time limit exceeded while waiting for syncpoint '%s'. "
+      "Time limit: %f sec.",
+      get_identifier().c_str(),
+      max_waittime_sec_ + static_cast<float>(max_waittime_nsec_)/1000000000.f);
+  bad_components_.insert(pending_emitters_.begin(), pending_emitters_.end());
+  if (bad_components_.size() > 1) {
+    string bad_components_string = "";
+    for (set<string>::const_iterator it = bad_components_.begin();
+        it != bad_components_.end(); it++) {
+      bad_components_string += " " + *it;
+    }
+    logger_->log_warn(component.c_str(), "bad components:%s",
+        bad_components_string.c_str());
+  }
+  else if (bad_components_.size() == 1) {
+    logger_->log_warn(component.c_str(), "bad component: %s",
+        bad_components_.begin()->c_str());
+  }
+  else if (type == SyncPoint::WAIT_FOR_ALL) {
+    throw Exception("SyncPoints: component %s defaulted, "
+        "but there is no pending emitter. This is probably a bug.",
+        component.c_str());
+  }
+
+  watchers_wait_for_all_.erase(component);
+  watchers_wait_for_one_.erase(component);
+}
+
+void
+SyncPoint::cleanup()
+{
+  delete cond_wait_for_one_;
+  delete mutex_wait_for_one_;
+  delete cond_wait_for_all_;
+  delete mutex_wait_for_all_;
+  delete mutex_next_wait_;
+  delete mutex_;
+}
+} // namespace fawkes
diff --git a/src/libs/syncpoint/syncpoint.h b/src/libs/syncpoint/syncpoint.h
new file mode 100644
index 000000000..c498c6105
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint.h
@@ -0,0 +1,185 @@
+/***************************************************************************
+ *  syncpoint.h - Fawkes SyncPoint
+ *
+ *  Created: Thu Jan 09 12:22:03 2014
+ *  Copyright  2014-2017  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __SYNCPOINT_SYNCPOINT_H_
+#define __SYNCPOINT_SYNCPOINT_H_
+
+#include <interface/interface.h>
+#include <syncpoint/syncpoint_call.h>
+#include <core/threading/mutex.h>
+#include <core/threading/wait_condition.h>
+#include <utils/time/time.h>
+
+#include <core/utils/refptr.h>
+#include <core/utils/circular_buffer.h>
+
+#include <logging/multi.h>
+
+#include <set>
+#include <map>
+#include <string>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointManager;
+class SyncPoint;
+
+class SyncPointSetLessThan {
+  public:
+    bool operator()(const RefPtr<SyncPoint> sp1, const RefPtr<SyncPoint> sp2) const;
+};
+
+
+class SyncPoint
+{
+  public:
+    /** Type to define when a thread wakes up after waiting for a SyncPoint.
+     * A thread can be either wake up if ANY other thread emits the SyncPoint,
+     * or if ALL registered threads emit the SyncPoint.
+     */
+    typedef enum {
+      WAIT_FOR_ONE,
+      WAIT_FOR_ALL,
+      NONE
+    } WakeupType;
+
+    SyncPoint(std::string identifier, MultiLogger *logger,
+      uint max_waittime_sec = 0, uint max_waittime_nsec = 0);
+    virtual ~SyncPoint();
+
+    /** send a signal to all waiting threads */
+    virtual void emit(const std::string & component);
+
+    /** wait for the sync point to be emitted by any other component */
+    virtual void wait(const std::string & component, WakeupType = WAIT_FOR_ONE,
+      uint wait_sec = 0, uint wait_nsec = 0);
+    virtual void wait_for_one(const std::string & component);
+    virtual void wait_for_all(const std::string & component);
+    /** wait for the sync point, but abort after given time */
+    virtual void reltime_wait_for_one(const std::string & component,
+      uint wait_sec, uint wait_nsec);
+    virtual void reltime_wait_for_all(const std::string & component,
+      uint wait_sec, uint wait_nsec);
+
+    /** register as emitter */
+    virtual void register_emitter(const std::string & component);
+
+    /** unregister as emitter */
+    virtual void unregister_emitter(const std::string & component, bool emit_if_pending = true);
+    bool is_emitter(const std::string & component) const;
+    bool is_watcher(const std::string & component) const;
+
+    void lock_until_next_wait(const std::string & component);
+
+    std::string get_identifier() const;
+    bool operator==(const SyncPoint & other) const;
+    bool operator==(const std::string & other) const;
+    bool operator<(const SyncPoint & other) const;
+
+    std::set<std::string> get_watchers() const;
+    std::multiset<std::string> get_emitters() const;
+    CircularBuffer<SyncPointCall> get_wait_calls(WakeupType type = WAIT_FOR_ONE) const;
+    CircularBuffer<SyncPointCall> get_emit_calls() const;
+    bool watcher_is_waiting(std::string watcher, WakeupType type) const;
+
+
+    /**
+     * allow Syncpoint Manager to edit
+     */
+    friend class SyncPointManager;
+
+  protected:
+    std::pair<std::set<std::string>::iterator,bool> add_watcher(std::string watcher);
+    /** send a signal to all waiting threads */
+    virtual void emit(const std::string & component, bool remove_from_pending);
+
+  protected:
+    /** The unique identifier of the SyncPoint */
+    const std::string identifier_;
+    /** Set of all components which use this SyncPoint */
+    std::set<std::string> watchers_;
+    /** Set of all components which are currently waiting for a single emitter */
+    std::set<std::string> watchers_wait_for_one_;
+    /** Set of all components which are currently waiting on the barrier */
+    std::set<std::string> watchers_wait_for_all_;
+
+    /** A buffer of the most recent emit calls. */
+    CircularBuffer<SyncPointCall> emit_calls_;
+    /** A buffer of the most recent wait calls of type WAIT_FOR_ONE. */
+    CircularBuffer<SyncPointCall> wait_for_one_calls_;
+    /** A buffer of the most recent wait calls of type WAIT_FOR_ALL. */
+    CircularBuffer<SyncPointCall> wait_for_all_calls_;
+    /** Time when this SyncPoint was created */
+    const Time creation_time_;
+
+    /** Mutex used to protect all member variables */
+    Mutex *mutex_;
+    /** Mutex used to allow lock_until_next_wait */
+    Mutex *mutex_next_wait_;
+    /** Mutex used for cond_wait_for_one_ */
+    Mutex *mutex_wait_for_one_;
+    /** WaitCondition which is used for wait_for_one() */
+    WaitCondition *cond_wait_for_one_;
+    /** Mutex used for cond_wait_for_all_ */
+    Mutex *mutex_wait_for_all_;
+    /** WaitCondition which is used for wait_for_all() */
+    WaitCondition *cond_wait_for_all_;
+    /** true if the wait for all timer is running */
+    bool wait_for_all_timer_running_;
+    /** maximum waiting time in secs */
+    uint max_waittime_sec_;
+    /** maximum waiting time in nsecs */
+    uint max_waittime_nsec_;
+
+    /** Logger */
+    MultiLogger *logger_;
+
+  private:
+    void reset_emitters();
+    bool is_pending(std::string component);
+    void handle_default(std::string component, WakeupType type);
+    void cleanup();
+
+  private:
+    /** The predecessor SyncPoint, which is the SyncPoint one level up
+     *  e.g. "/test/sp" -> "/test"
+     */
+    RefPtr<SyncPoint> predecessor_;
+
+    /** all successors */
+    std::set<RefPtr<SyncPoint>, SyncPointSetLessThan > successors_;
+
+    std::multiset<std::string> emitters_;
+    std::multiset<std::string> pending_emitters_;
+
+    std::set<std::string> bad_components_;
+
+    std::string emit_locker_;
+
+    Time last_emitter_reset_;
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/syncpoint/syncpoint_call.cpp b/src/libs/syncpoint/syncpoint_call.cpp
new file mode 100644
index 000000000..4bb0ea8dc
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_call.cpp
@@ -0,0 +1,74 @@
+/***************************************************************************
+ *  syncpoint_call.cpp - Utility class to represent a call to a SyncPoint
+ *
+ *  Created: Fri Aug 15 18:12:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <syncpoint/syncpoint_call.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointCall <syncpoint/syncpoint.h>
+ * A call (wait() or emit()) to a SyncPoint.
+ * @author Till Hofmann
+ * @see SyncPoint
+ */
+
+/** Constructor.
+ * @param call_time Time at which the SyncPoint was called
+ * @param caller The calling component
+ * @param wait_time The time the caller had to wait for the SyncPoint (wait calls)
+ */
+SyncPointCall::SyncPointCall(const std::string & caller, Time call_time, Time wait_time)
+  : caller_(caller),
+    call_time_(call_time),
+    wait_time_(wait_time)
+{}
+
+/** Get the time when the call was made
+ * @return the call time
+ */
+Time
+SyncPointCall::get_call_time() const
+{
+  return call_time_;
+}
+
+/** Get the wait time
+ * @return the wait time
+ */
+Time
+SyncPointCall::get_wait_time() const
+{
+  return wait_time_;
+}
+
+/** Get the name of the component which made the call
+ * @return the component name
+ */
+std::string
+SyncPointCall::get_caller() const
+{
+  return caller_;
+}
+
+
+} // namespace fawkes
diff --git a/src/libs/syncpoint/syncpoint_call.h b/src/libs/syncpoint/syncpoint_call.h
new file mode 100644
index 000000000..7989e600d
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_call.h
@@ -0,0 +1,54 @@
+/***************************************************************************
+ *  syncpoint_call.h - Utility class to represent a call to a SyncPoint
+ *
+ *  Created: Fri Aug 15 18:12:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __SYNCPOINT_SYNCPOINT_CALL_H_
+#define __SYNCPOINT_SYNCPOINT_CALL_H_
+
+#include <utils/time/time.h>
+
+#include <string>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointCall
+{
+  public:
+    SyncPointCall(const std::string & caller, Time call_time = Time(), Time wait_time =
+      Time(0.f));
+
+  public:
+    Time get_call_time() const;
+    Time get_wait_time() const;
+    std::string get_caller() const;
+
+  private:
+    const std::string caller_;
+    const Time call_time_;
+    const Time wait_time_;
+};
+
+
+} // namespace fawkes
+
+#endif
diff --git a/src/libs/syncpoint/syncpoint_call_stats.cpp b/src/libs/syncpoint/syncpoint_call_stats.cpp
new file mode 100644
index 000000000..969cf75cb
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_call_stats.cpp
@@ -0,0 +1,122 @@
+/***************************************************************************
+ *  syncpoint_call_stats.cpp - Utility class to keep track of SP call stats
+ *
+ *  Created: Fri Aug 15 16:17:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <syncpoint/syncpoint_call_stats.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointCallStats <syncpoint/syncpoint_call_stats.h>
+ * This class represents call stats of a single component to a single SyncPoint.
+ * It keeps track of the first and last call and computes the call frequency.
+ *
+ * @see SyncPoint
+ * @see SyncPointCall
+ *
+ */
+
+/** Constructor. */
+SyncPointCallStats::SyncPointCallStats()
+: first_call_(TIME_MAX),
+  last_call_(TIME_MIN),
+  total_wait_time_(Time(0.f)),
+  num_calls_(0)
+{}
+
+/** Add a call to the stats.
+ * Update the first and last call and increment the call counter
+ * @param new_call the time of the call
+ * @param wait_time the time the caller had to wait, 0 for emit()
+ */
+void
+SyncPointCallStats::update_calls(Time new_call, Time wait_time)
+{
+  num_calls_++;
+  total_wait_time_ += wait_time;
+  if (new_call < first_call_) {
+    first_call_ = new_call;
+  }
+  if (new_call > last_call_) {
+    last_call_ = new_call;
+  }
+}
+
+/** Add a call to the stats.
+ * @param call the new call
+ */
+void
+SyncPointCallStats::update_calls(SyncPointCall call)
+{
+  update_calls(call.get_call_time(), call.get_wait_time());
+}
+
+/** Get the first call to the SyncPoint by the component
+ * @return The time of the first call
+ */
+Time
+SyncPointCallStats::get_first_call() const
+{
+  return first_call_;
+}
+
+/** Get the last call to the SyncPoint by the component
+ * @return The time of the last call
+ */
+Time
+SyncPointCallStats::get_last_call() const
+{
+  return last_call_;
+}
+
+/** Get the call frequency. This is calculated using the first and last call
+ * and the number of calls
+ * @return the call frequency
+ */
+float
+SyncPointCallStats::get_call_frequency() const
+{
+  if (num_calls_ <= 1) {
+    return 0.f;
+  }
+  return num_calls_ / (last_call_.in_sec() - first_call_.in_sec());
+}
+
+/** Get the average wait time. For emit calls, this is 0.
+ * @return average wait time
+ */
+float
+SyncPointCallStats::get_waittime_average() const
+{
+  return total_wait_time_.in_sec() / num_calls_;
+}
+
+/** Get total number of calls.
+ * @return the total number of calls
+ */
+unsigned int
+SyncPointCallStats::get_num_calls() const
+{
+  return num_calls_;
+}
+
+} // namespace fawkes
diff --git a/src/libs/syncpoint/syncpoint_call_stats.h b/src/libs/syncpoint/syncpoint_call_stats.h
new file mode 100644
index 000000000..53041be0c
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_call_stats.h
@@ -0,0 +1,55 @@
+/***************************************************************************
+ *  syncpoint_call_stats.h - Utility class to keep track of SP call stats
+ *
+ *  Created: Fri Aug 15 16:17:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __SYNCPOINT_SYNCPOINT_CALL_STATS_H_
+#define __SYNCPOINT_SYNCPOINT_CALL_STATS_H_
+
+#include <utils/time/time.h>
+
+#include <syncpoint/syncpoint_call.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPointCallStats {
+  public:
+    SyncPointCallStats();
+
+    void update_calls(Time new_call, Time wait_time = Time(0.f));
+    void update_calls(SyncPointCall call);
+    Time get_first_call() const;
+    Time get_last_call() const;
+    float get_call_frequency() const;
+    float get_waittime_average() const;
+    unsigned int get_num_calls() const;
+
+  private:
+    Time first_call_;
+    Time last_call_;
+    Time total_wait_time_;
+    unsigned int num_calls_;
+};
+
+} // namespace fawkes
+
+#endif
diff --git a/src/libs/syncpoint/syncpoint_manager.cpp b/src/libs/syncpoint/syncpoint_manager.cpp
new file mode 100644
index 000000000..a29dbc2f0
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_manager.cpp
@@ -0,0 +1,213 @@
+/***************************************************************************
+ *  syncpoint_manager.cpp - Fawkes SyncPointManager
+ *
+ *  Created: Thu Jan 09 15:22:19 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <core/threading/mutex_locker.h>
+
+#include <syncpoint/syncpoint_manager.h>
+#include <syncpoint/exceptions.h>
+
+#include "syncpoint_call_stats.h"
+
+#include <string>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+/** @class SyncPointManager <syncpoint/syncpoint_manager.h>
+ * This class gives access to SyncPoints. SyncPoints should never be created
+ * directly but always by using this class.
+ *
+ * All threads with the SyncPointManager Aspect share the same SyncPointManager.
+ * SyncPointManager provides basic methods to get and release shared SyncPoints
+ *
+ * @author Till Hofmann
+ * @see SyncPoint
+ */
+
+/** Constructor.
+ *  @param logger the logger to use for logging messages
+ */
+SyncPointManager::SyncPointManager(MultiLogger *logger)
+: mutex_(new Mutex()),
+  logger_(logger)
+{
+}
+
+SyncPointManager::~SyncPointManager()
+{
+  delete mutex_;
+}
+
+/**
+ * Get a SyncPoint. This allows accessing the SyncPoint's wait() and emit() methods.
+ * This function creates a SyncPoint with the given identifier if it does not
+ * exist yet and constructs its predecessor.
+ * @param component The name of the component calling the method
+ * @param identifier The identifier of the requested SyncPoint
+ * @return A RefPtr to a SyncPoint which is shared by all threads with this
+ * SyncPoint.
+ * @throw SyncPointInvalidComponentException thrown if component name is invalid
+ * @throw SyncPointAlreadyOpenedException thrown if SyncPoint is already opened
+ * by the component
+ */
+RefPtr<SyncPoint>
+SyncPointManager::get_syncpoint(const std::string & component, const std::string & identifier)
+{
+  MutexLocker ml(mutex_);
+  return get_syncpoint_no_lock(component, identifier);
+}
+
+/**
+ * Release a SyncPoint. After releasing the SyncPoint, its wait() and emit()
+ * methods cannot be called anymore by the releasing component.
+ * This also releases the SyncPoint's predecessor if existent.
+ * @param component The releasing component
+ * @param sync_point A RefPtr to the released SyncPoint
+ * @throw SyncPointReleasedDoesNotExistException thrown if the SyncPoint doesn't
+ * exist, i.e. is not in the list of the manager's SyncPoints.
+ * @throw SyncPointReleasedByNonWatcherException The releasing component is not
+ * a watcher of the SyncPoint
+ */
+void
+SyncPointManager::release_syncpoint(const std::string & component, RefPtr<SyncPoint> sync_point)
+{
+  MutexLocker ml(mutex_);
+  release_syncpoint_no_lock(component, sync_point);
+}
+
+/** @class SyncPointSetLessThan "syncpoint_manager.h"
+ * Compare sets of syncpoints
+ */
+
+/**
+ * LessThan Operator to use for the manager's SyncPoint set
+ * Since we store RefPtrs to SyncPoints we have to override this operator
+ * otherwise, each SyncPoint would be unique
+ * @param sp1 A RefPtr to a SyncPoint
+ * @param sp2 A RefPtr to a SyncPoint
+ * @return true if strcmp returns a value < 0 for the SyncPoints' identifiers
+ */
+bool
+SyncPointSetLessThan::operator()(const RefPtr<SyncPoint> sp1, const RefPtr<SyncPoint> sp2) const {
+  return **sp1 < **sp2;
+}
+
+/**
+ * Get the current list of all SyncPoints managed by this SyncPointManager
+ * @return a set of SyncPoints
+ */
+std::set<RefPtr<SyncPoint>, SyncPointSetLessThan >
+SyncPointManager::get_syncpoints() {
+  MutexLocker ml(mutex_);
+  return syncpoints_;
+}
+
+
+/** Find the prefix of the SyncPoint's identifier which is the identifier of
+ *  the direct predecessor SyncPoint.
+ *  The predecessor of a SyncPoint "/some/path" is "/some"
+ *  @param identifier The identifier of the SyncPoint
+ *  @return The identifier of the predecessor SyncPoint
+ */
+std::string
+SyncPointManager::find_prefix(const std::string & identifier) const
+{
+  size_t last_pos = identifier.rfind("/");
+  if (last_pos != 0) {
+    return identifier.substr(0, last_pos);
+  } else {
+    return "/";
+  }
+}
+
+RefPtr<SyncPoint>
+SyncPointManager::get_syncpoint_no_lock(const std::string & component, const std::string & identifier)
+{
+  if (component == "") {
+    throw SyncPointInvalidComponentException(component.c_str(), identifier.c_str());
+  }
+  // insert a new SyncPoint if no SyncPoint with the same identifier exists,
+  // otherwise, use that SyncPoint
+  std::pair<std::set<RefPtr<SyncPoint> >::iterator,bool> insert_ret;
+  insert_ret = syncpoints_.insert(
+      RefPtr<SyncPoint>(new SyncPoint(identifier, logger_)));
+  std::set<RefPtr<SyncPoint> >::iterator sp_it = insert_ret.first;
+
+  // add component to the set of watchers
+  (*sp_it)->add_watcher(component);
+
+  if (identifier != "/") {
+    // create prefix SyncPoints.
+    // If this is the root SyncPoint ("/"), there will be no prefix
+    std::string prefix = find_prefix(identifier);
+    RefPtr<SyncPoint> predecessor = get_syncpoint_no_lock(component, prefix);
+    predecessor->successors_.insert(*sp_it);
+    (*sp_it)->predecessor_ = predecessor;
+  }
+
+  return *sp_it;
+}
+
+
+void
+SyncPointManager::release_syncpoint_no_lock(const std::string & component,
+  RefPtr<SyncPoint> sync_point)
+{
+  std::set<RefPtr<SyncPoint> >::iterator sp_it = syncpoints_.find(sync_point);
+  if (sp_it == syncpoints_.end()) {
+    throw SyncPointReleasedDoesNotExistException(component.c_str(),
+        sync_point->get_identifier().c_str());
+  }
+  if (component_watches_any_successor(sync_point, component)) {
+    // successor is watched, do not release the syncpoint yet
+    return;
+  }
+  if (!(*sp_it)->watchers_.erase(component)) {
+    throw SyncPointReleasedByNonWatcherException(component.c_str(),
+        sync_point->get_identifier().c_str());
+  }
+  if ((*sp_it)->is_emitter(component) && !(*sp_it)->is_watcher(component)) {
+	  throw SyncPointCannotReleaseEmitter(component.c_str(),
+	      (*sp_it)->get_identifier().c_str());
+  }
+
+  if (sync_point->predecessor_) {
+    release_syncpoint_no_lock(component, sync_point->predecessor_);
+  }
+}
+
+bool
+SyncPointManager::component_watches_any_successor(
+  const RefPtr<SyncPoint> syncpoint, const std::string component) const
+{
+  for (std::set<RefPtr<SyncPoint> >::const_iterator it = syncpoint->successors_.begin();
+      it != syncpoint->successors_.end();
+      it++) {
+    if ((*it)->get_watchers().count(component)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+} // namespace fawkes
diff --git a/src/libs/syncpoint/syncpoint_manager.h b/src/libs/syncpoint/syncpoint_manager.h
new file mode 100644
index 000000000..6f06c1b7d
--- /dev/null
+++ b/src/libs/syncpoint/syncpoint_manager.h
@@ -0,0 +1,73 @@
+/***************************************************************************
+ *  syncpoint_manager.h - Fawkes SyncPointManager
+ *
+ *  Created: Thu Jan 09 15:17:03 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __SYNCPOINT_SYNCPOINT_MANAGER_H_
+#define __SYNCPOINT_SYNCPOINT_MANAGER_H_
+
+#include <set>
+#include <string>
+
+#include <syncpoint/syncpoint.h>
+#include <core/utils/refptr.h>
+#include <core/threading/mutex.h>
+
+#include <logging/multi.h>
+
+namespace fawkes {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+
+class SyncPoint;
+
+
+class SyncPointManager
+{
+  public:
+    SyncPointManager(MultiLogger *logger);
+    virtual ~SyncPointManager();
+
+    RefPtr<SyncPoint> get_syncpoint(const std::string & component, const std::string & identifier);
+    void release_syncpoint(const std::string & component, RefPtr<SyncPoint> syncpoint);
+
+    std::set<RefPtr<SyncPoint>, SyncPointSetLessThan > get_syncpoints();
+
+  protected:
+    /** Set of all existing SyncPoints */
+    std::set<RefPtr<SyncPoint>, SyncPointSetLessThan > syncpoints_;
+    /** Mutex used for all SyncPointManager calls */
+    Mutex *mutex_;
+
+  private:
+    std::string find_prefix(const std::string & identifier) const;
+    RefPtr<SyncPoint> get_syncpoint_no_lock(const std::string & component,
+      const std::string & identifier);
+    void release_syncpoint_no_lock(const std::string & component,
+      RefPtr<SyncPoint> syncpoint);
+    bool component_watches_any_successor(const RefPtr<SyncPoint> sp,
+      const std::string component) const;
+    MultiLogger *logger_;
+
+};
+
+} // end namespace fawkes
+
+#endif
diff --git a/src/libs/syncpoint/tests/Makefile b/src/libs/syncpoint/tests/Makefile
new file mode 100644
index 000000000..4c773fa27
--- /dev/null
+++ b/src/libs/syncpoint/tests/Makefile
@@ -0,0 +1,34 @@
+#*****************************************************************************
+#               Makefile Build System for Fawkes: SyncPoint Unit Test
+#                            -------------------
+#   Created on Wed Jan 22 16:07:03 2014
+#   Copyright (C) 2014 by Till Hofmann
+#
+#*****************************************************************************
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#*****************************************************************************
+
+BASEDIR = ../../../..
+include $(BASEDIR)/etc/buildsys/config.mk
+include $(BASEDIR)/etc/buildsys/gtest.mk
+
+CFLAGS += -Wno-unused-but-set-variable -Wno-unused-variable
+LIBS_gtest_syncpoint += stdc++ fawkescore fawkesutils fawkessyncpoint pthread \
+                        fawkeslogging
+
+OBJS_gtest_syncpoint += test_syncpoint.o
+OBJS_all = $(OBJS_gtest_syncpoint)
+
+ifeq ($(HAVE_GTEST)$(HAVE_CPP11),11)
+  CFLAGS += $(CFLAGS_GTEST) $(CFLAGS_CPP11)
+  LDFLAGS += $(LDFLAGS_GTEST)
+  LIBS_test = $(LIBDIR)/test/syncpoint.so
+  BINS_test = $(BINDIR)/gtest_syncpoint
+endif
+
+include $(BUILDSYSDIR)/base.mk
diff --git a/src/libs/syncpoint/tests/test_syncpoint.cpp b/src/libs/syncpoint/tests/test_syncpoint.cpp
new file mode 100644
index 000000000..d415b29f4
--- /dev/null
+++ b/src/libs/syncpoint/tests/test_syncpoint.cpp
@@ -0,0 +1,1275 @@
+/***************************************************************************
+ *  test_syncpoint.cpp - SyncPoint Unit Test
+ *
+ *  Created: Wed Jan 22 11:17:43 2014
+ *  Copyright  2014-2017  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <gtest/gtest.h>
+
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+#include <time.h>
+
+#include <string>
+
+#include <libs/syncpoint/syncpoint.h>
+#include <libs/syncpoint/syncpoint_manager.h>
+#include <libs/syncpoint/exceptions.h>
+
+#include <logging/multi.h>
+#include <logging/cache.h>
+
+#include <core/utils/refptr.h>
+
+using namespace fawkes;
+using namespace std;
+
+
+/** @class SyncPointTest
+ * Test class for SyncPoint
+ * This class tests basic functionality of SyncPoints
+ */
+class SyncPointTest : public ::testing::Test
+{
+
+  protected:
+    /**
+     * Initialize the test class
+     */
+    virtual void SetUp()
+    {
+      logger_ = new MultiLogger();
+      string id1 = "/id1";
+      string id2 = "/id2";
+      sp1 = new SyncPoint(id1, logger_);
+      sp2 = new SyncPoint(id1, logger_);
+      sp3 = new SyncPoint(id2, logger_);
+    }
+
+    /** Clean up */
+    virtual void TearDown()
+    {
+      delete logger_;
+    }
+
+
+    /**@{*/
+    /**
+     * Syncpoints for testing purposes
+     */
+    RefPtr<SyncPoint> sp1;
+    RefPtr<SyncPoint> sp2;
+    RefPtr<SyncPoint> sp3;
+    /**@}*/
+
+    /** Logger for testing */
+    MultiLogger *logger_;
+
+};
+
+/** @class SyncPointManagerTest
+ * Test class for SyncPointManager
+ * This class tests basic functionality of the SyncPointManager
+ */
+class SyncPointManagerTest : public ::testing::Test
+{
+  protected:
+    /**
+     * Initialize the test class
+     */
+    SyncPointManagerTest()
+    {
+      logger_ = new MultiLogger();
+      cache_logger_ = new CacheLogger();
+      logger_->add_logger(cache_logger_);
+      manager = new SyncPointManager(logger_);
+
+      pthread_attr_init(&attrs);
+
+    }
+
+    /**
+     * Deinitialize the test class
+     */
+    virtual ~SyncPointManagerTest()
+    {
+      pthread_attr_destroy(&attrs);
+      delete logger_;
+//      delete cache_logger_;
+    }
+
+    /**
+     * A Pointer to a SyncPointManager
+     */
+    RefPtr<SyncPointManager> manager;
+
+    /** Logger used to initialize SyncPoints */
+    MultiLogger *logger_;
+
+    /** Cache Logger used for testing */
+    CacheLogger *cache_logger_;
+
+    /** Thread attributes */
+    pthread_attr_t attrs;
+};
+
+/** @class SyncBarrierTest
+ *  Test SyncBarriers
+ */
+class SyncBarrierTest : public SyncPointManagerTest
+{
+protected:
+  /** Constructor. */
+  SyncBarrierTest()
+  {
+  }
+};
+
+TEST_F(SyncPointTest, CreateSyncPoint)
+{
+  ASSERT_TRUE(*sp1 != NULL);
+}
+
+TEST_F(SyncPointTest, Equals)
+{
+  // RefPtr<SyncPoint>
+  ASSERT_NE(sp1, sp2);
+  // SyncPoint*
+  ASSERT_NE(*sp1, *sp2);
+  // SyncPoint
+  ASSERT_EQ(**sp1, **sp2);
+}
+
+TEST_F(SyncPointTest, LessThan)
+{
+  ASSERT_LT(**sp1, **sp3);
+  ASSERT_FALSE(**sp3 < **sp1);
+  ASSERT_FALSE(**sp1 < **sp2);
+  ASSERT_FALSE(**sp2 < **sp1);
+}
+
+TEST_F(SyncPointTest, SyncPointSets)
+{
+  using namespace std;
+  set<RefPtr<SyncPoint>, SyncPointSetLessThan > sp_set;
+  pair<set<RefPtr<SyncPoint> >::iterator, bool> ret;
+
+  // insert sp1
+  ret = sp_set.insert(sp1);
+  ASSERT_TRUE(ret.second);
+  ASSERT_EQ(sp1->get_identifier(), (*(ret.first))->get_identifier());
+
+  // insert sp3
+  ret = sp_set.insert(sp3);
+  ASSERT_TRUE(ret.second);
+  ASSERT_EQ(sp3->get_identifier(), (*(ret.first))->get_identifier());
+
+  // insert sp1 again
+  ret = sp_set.insert(sp1);
+  ASSERT_FALSE(ret.second);
+  ASSERT_EQ(sp1->get_identifier(), (*(ret.first))->get_identifier());
+
+  // insert sp2 (same as sp1)
+  ret = sp_set.insert(sp2);
+  ASSERT_FALSE(ret.second);
+  ASSERT_EQ(sp2->get_identifier(), (*(ret.first))->get_identifier());
+}
+
+TEST_F(SyncPointManagerTest, SyncPointManager)
+{
+  ASSERT_EQ(0u, manager->get_syncpoints().size());
+  manager->get_syncpoint("test", "/test/1");
+  ASSERT_EQ(3u, manager->get_syncpoints().size());
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test/1", logger_))));
+  manager->get_syncpoint("test2", "/test/2");
+  ASSERT_EQ(4u, manager->get_syncpoints().size());
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test/1", logger_))));
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test/2", logger_))));
+  manager->get_syncpoint("test3", "/test/1");
+  ASSERT_EQ(4u, manager->get_syncpoints().size());
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test/1", logger_))));
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test/2", logger_))));
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/", logger_))));
+  ASSERT_EQ(1u,
+      manager->get_syncpoints().count(
+          RefPtr<SyncPoint>(new SyncPoint("/test", logger_))));
+}
+
+TEST_F(SyncPointManagerTest, WatcherSet)
+{
+  ASSERT_NO_THROW(manager->get_syncpoint("component 1", "/test"));
+  ASSERT_NO_THROW(manager->get_syncpoint("component 2", "/test"));
+  ASSERT_NO_THROW(manager->get_syncpoint("component 3", "/test"));
+}
+
+/** Test what happens if we acquire a SyncPoint, release it, and then acquire it
+ * again. If release_syncpoint works properly, this should not throw. Otherwise,
+ * we would expect a SyncPointAlreadyOpenedException
+ */
+TEST_F(SyncPointManagerTest, ReleaseAndReacquire)
+{
+  string comp = "component";
+  string id = "/test/sp1";
+  RefPtr<SyncPoint> sp = manager->get_syncpoint(comp, id);
+  set<RefPtr<SyncPoint>, SyncPointSetLessThan > syncpoints = manager->get_syncpoints();
+  ASSERT_EQ(1,
+      syncpoints.count(
+          RefPtr<SyncPoint>(new SyncPoint("/test", logger_))));
+  for (set<RefPtr<SyncPoint> >::const_iterator sp_it = syncpoints.begin();
+      sp_it != syncpoints.end(); sp_it++) {
+    EXPECT_EQ(1, (*sp_it)->get_watchers().count(comp))
+        << "for component '" << comp << "' and SyncPoint '"
+        << (*sp_it)->get_identifier() << "'";
+  }
+  manager->release_syncpoint(comp, sp);
+  for (set<RefPtr<SyncPoint> >::const_iterator sp_it = syncpoints.begin();
+      sp_it != syncpoints.end(); sp_it++) {
+    EXPECT_EQ(0, (*sp_it)->get_watchers().count(comp)) << "for component '"
+        << comp << "' and SyncPoint '" << (*sp_it)->get_identifier() << "'";
+  }
+  ASSERT_NO_THROW(manager->get_syncpoint(comp, id));
+}
+
+TEST_F(SyncPointTest, EmptyIdentifier)
+{
+  ASSERT_THROW(sp1 = new SyncPoint("", NULL), SyncPointInvalidIdentifierException);
+}
+
+TEST_F(SyncPointTest, InvalidIdentifier)
+{
+  EXPECT_THROW(sp1 = new SyncPoint("invalid", NULL),
+      SyncPointInvalidIdentifierException);
+  EXPECT_NO_THROW(sp1 = new SyncPoint("/", NULL));
+  EXPECT_THROW(sp1 = new SyncPoint("/test/", NULL),
+      SyncPointInvalidIdentifierException);
+}
+
+TEST_F(SyncPointManagerTest, SyncPointManagerExceptions) {
+  RefPtr<SyncPoint> invalid_sp;
+  ASSERT_THROW(invalid_sp = manager->get_syncpoint("", "/test/sp1"),
+      SyncPointInvalidComponentException);
+
+  // make sure syncpoint_manager doesn't catch the exceptions thrown by SyncPoint
+  ASSERT_THROW(invalid_sp = manager->get_syncpoint("waiter", ""),
+      SyncPointInvalidIdentifierException);
+  ASSERT_THROW(invalid_sp = manager->get_syncpoint("waiter", "invalid"),
+        SyncPointInvalidIdentifierException);
+}
+
+TEST_F(SyncPointManagerTest, SyncPointHierarchyRegisteredWatchers)
+{
+  string comp = "component1";
+  string id = "/test/sp1";
+  RefPtr<SyncPoint> sp = manager->get_syncpoint(comp, "/test/sp1");
+  set<RefPtr<SyncPoint>, SyncPointSetLessThan > syncpoints = manager->get_syncpoints();
+  set<RefPtr<SyncPoint>>::iterator sp_test_it = syncpoints.find(
+      RefPtr<SyncPoint>(new SyncPoint("/test", logger_)));
+  set<RefPtr<SyncPoint>>::iterator sp_root_it = syncpoints.find(
+      RefPtr<SyncPoint>(new SyncPoint("/", logger_)));
+  ASSERT_NE(syncpoints.end(), sp_test_it);
+  ASSERT_NE(syncpoints.end(), sp_root_it);
+  RefPtr<SyncPoint> sp_test = *sp_test_it;
+  RefPtr<SyncPoint> sp_root = *sp_root_it;
+  EXPECT_EQ(1, syncpoints.count(sp_test));
+  EXPECT_EQ(1, syncpoints.count(sp_root));
+  EXPECT_EQ(1, sp->get_watchers().count(comp));
+  EXPECT_EQ(1, sp_test->get_watchers().count(comp));
+  EXPECT_EQ(0, sp_test->get_watchers().count(id));
+  EXPECT_EQ(1, sp_root->get_watchers().count(comp));
+  EXPECT_EQ(0, sp_root->get_watchers().count(id));
+  EXPECT_EQ(0,
+      sp_root->get_watchers().count(
+          sp_test->get_identifier()));
+
+  manager->release_syncpoint(comp, sp);
+  EXPECT_EQ(0, sp_test->get_watchers().count(id));
+}
+
+TEST_F(SyncPointManagerTest, SyncPointComponentRegistersForMultipleSyncPoints)
+{
+  string comp = "component1";
+  string sp1_id = "/test/sp1";
+  string sp2_id = "/test/sp2";
+  RefPtr<SyncPoint> sp1 = manager->get_syncpoint(comp, sp1_id);
+  // the following should not throw
+  // if it does, registering for the predecessor '/test' may be broken
+  RefPtr<SyncPoint> sp2 = manager->get_syncpoint(comp, sp2_id);
+  RefPtr<SyncPoint> predecessor = *manager->get_syncpoints().find(
+      RefPtr<SyncPoint>(new SyncPoint("/test", logger_)));
+  EXPECT_EQ(1, sp1->get_watchers().count(comp))
+      << comp << " is not registered for " << sp1->get_identifier()
+      << ", but should be!";
+  EXPECT_EQ(1, sp2->get_watchers().count(comp))
+      << comp << " is not registered for " << sp2->get_identifier()
+      << ", but should be!";
+  EXPECT_EQ(1, predecessor->get_watchers().count(comp))
+      << comp << " is not registered for " << predecessor->get_identifier()
+      << ", but should be!";
+
+  manager->release_syncpoint(comp, sp1);
+  EXPECT_EQ(1, sp2->get_watchers().count(comp));
+  EXPECT_EQ(1, predecessor->get_watchers().count(comp))
+      << comp << " is not registered for " << predecessor->get_identifier()
+      << ", but should be!";
+}
+
+// helper function used for testing wait()
+void * call_wait(void *data)
+{
+  SyncPoint * sp = (SyncPoint *)(data);
+  sp->wait("component");
+  return NULL;
+}
+
+TEST_F(SyncPointManagerTest, MultipleWaits)
+{
+  RefPtr<SyncPoint> sp_ref = manager->get_syncpoint("component", "/test/sp1");
+  SyncPoint * sp = *sp_ref;
+  pthread_t thread1;
+  pthread_create(&thread1, &attrs, call_wait, (void *)sp);
+  // make sure the other thread is first
+  usleep(10000);
+  ASSERT_THROW(sp_ref->wait("component"), SyncPointMultipleWaitCallsException);
+  pthread_cancel(thread1);
+  pthread_join(thread1, NULL);
+}
+
+
+/** struct used for multithreading tests */
+struct waiter_thread_params {
+    /** SyncPointManager passed to the thread */
+    RefPtr<SyncPointManager> manager;
+    /** Thread number */
+    uint thread_nr = 0;
+    /** Number of wait calls the thread should make */
+    uint num_wait_calls;
+    /** Name of the SyncPoint */
+    string sp_identifier;
+    /** Name of the component */
+    string component = "";
+    /** timeout in sec */
+    uint timeout_sec = 0;
+    /** timeout in nsec */
+    uint timeout_nsec = 0;
+};
+
+
+/** get a SyncPoint and wait for it */
+void * start_waiter_thread(void * data) {
+  waiter_thread_params *params = (waiter_thread_params *)data;
+  string component = params->component;
+  if (component == "") {
+    char *comp;
+    asprintf(&comp, "component %u", params->thread_nr);
+    component = comp;
+    free(comp);
+  }
+  RefPtr<SyncPoint> sp = params->manager->get_syncpoint(component, params->sp_identifier);
+  for (uint i = 0; i < params->num_wait_calls; i++) {
+    sp->wait(component, SyncPoint::WAIT_FOR_ONE, params->timeout_sec,
+        params->timeout_nsec);
+  }
+  pthread_exit(NULL);
+}
+
+/** Create multiple threads which will all call get_syncpoint
+ *  for the same SyncPoint. Do not wait for the SyncPoint but return
+ *  immediately.
+ */
+TEST_F(SyncPointManagerTest, MultipleManagerRequests)
+{
+  uint num_threads = 50;
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  string sp_identifier = "/test/sp1";
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = 0;
+    params[i]->sp_identifier = sp_identifier;
+    pthread_create(&threads[i], &attrs, start_waiter_thread, params[i]);
+    pthread_yield();
+    ASSERT_LE(manager->get_syncpoints().size(), 3u);
+  }
+
+  for (uint i = 0; i < num_threads; i++) {
+    pthread_join(threads[i], NULL);
+    delete params[i];
+  }
+}
+
+
+/** start multiple threads and let them wait.
+ *  This just tests whether there are any segfaults.
+ *  No assertions are made.
+ */
+TEST_F(SyncPointManagerTest, ParallelWaitCalls)
+{
+  uint num_threads = 50;
+  uint num_wait_calls = 10;
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  string sp_identifier = "/test/sp1";
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = num_wait_calls;
+    params[i]->sp_identifier = sp_identifier;
+    pthread_create(&threads[i], &attrs, start_waiter_thread, params[i]);
+    pthread_yield();
+    ASSERT_LE(manager->get_syncpoints().size(), 3u);
+  }
+
+  usleep(10000);
+  for (uint i = 0; i < num_threads; i++) {
+    pthread_cancel(threads[i]);
+    ASSERT_EQ(0,pthread_join(threads[i], NULL));
+    delete params[i];
+  }
+}
+
+/** start multiple threads, let them wait for a SyncPoint,
+ * emit the SyncPoint and verify that they all returned
+ */
+TEST_F(SyncPointManagerTest, ParallelWaitsReturn)
+{
+
+  uint num_threads = 50;
+  uint num_wait_calls = 10;
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  string sp_identifier = "/test/sp1";
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = num_wait_calls;
+    params[i]->sp_identifier = sp_identifier;
+    pthread_create(&threads[i], &attrs, start_waiter_thread, params[i]);
+    usleep(10000);
+  }
+
+  string component = "emitter";
+  RefPtr<SyncPoint> sp = manager->get_syncpoint(component, sp_identifier);
+  sp->register_emitter(component);
+  for (uint i = 0; i < num_wait_calls; i++) {
+    sp->emit(component);
+    usleep(10000);
+  }
+
+  sleep(1);
+  for (uint i = 0; i < num_threads; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+    delete params[i];
+  }
+}
+
+/** start multiple threads, let them wait for a SyncPoint,
+ * but don't emit the SyncPoint. Verify that they have not returned
+ */
+TEST_F(SyncPointManagerTest, WaitDoesNotReturnImmediately)
+{
+  uint num_threads = 50;
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = 1;
+    params[i]->sp_identifier = "/test/sp1";
+    pthread_create(&threads[i], &attrs, start_waiter_thread, params[i]);
+  }
+
+  sleep(1);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+    pthread_cancel(threads[i]);
+    ASSERT_EQ(0, pthread_join(threads[i], NULL));
+    delete params[i];
+  }
+}
+
+/**
+ * Test the SyncPoint hierarchy.
+ * This creates a SyncPoint, an emitter and waiters which wait for the
+ * SyncPoint's predecessor, the predecessor's predecessor (grandparent),
+ * and the root SyncPoint ("/").
+ */
+TEST_F(SyncPointManagerTest, SyncPointHierarchy)
+{
+  vector<string> identifiers = { "/test/topic", "/test", "/", "/other/topic" };
+  uint num_threads = identifiers.size();
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = 1;
+    params[i]->sp_identifier = identifiers.at(i);
+    pthread_create(&threads[i], &attrs, start_waiter_thread, params[i]);
+  }
+
+  usleep(10000);
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter", "/test/topic/sp");
+  sp->register_emitter("emitter");
+  sp->emit("emitter");
+  usleep(10000);
+
+  /* The first waiters should be unblocked */
+  for (uint i = 0; i < num_threads - 1 ; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+    delete params[i];
+  }
+
+  /* The last waiter should still wait */
+  pthread_t last_thread = threads[num_threads-1];
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(last_thread, NULL));
+  pthread_cancel(last_thread);
+  ASSERT_EQ(0, pthread_join(last_thread, NULL));
+}
+
+/** Emit a barrier without registering */
+TEST_F(SyncBarrierTest, EmitWithoutRegister)
+{
+  string component = "emitter";
+  RefPtr<SyncPoint> barrier = manager->get_syncpoint(component, "/test/barrier");
+  ASSERT_THROW(barrier->emit(component), SyncPointNonEmitterCalledEmitException);
+}
+
+/** Register multiple times
+ * This is allowed, but the component should then also emit multiple times */
+TEST_F(SyncBarrierTest, MultipleRegisterCalls)
+{
+  string component = "emitter";
+  RefPtr<SyncPoint> barrier = manager->get_syncpoint(component, "/test/barrier");
+  EXPECT_NO_THROW(barrier->register_emitter(component));
+  EXPECT_NO_THROW(barrier->register_emitter(component));
+}
+
+/** get a SyncBarrier and wait for it */
+void * start_barrier_waiter_thread(void * data) {
+  waiter_thread_params *params = (waiter_thread_params *)data;
+  char *comp;
+  asprintf(&comp, "component %u", params->thread_nr);
+  string component = comp;
+  free(comp);
+  RefPtr<SyncPoint> sp;
+  sp = params->manager->get_syncpoint(component, params->sp_identifier);
+  for (uint i = 0; i < params->num_wait_calls; i++) {
+    sp->wait(component, SyncPoint::WAIT_FOR_ALL, params->timeout_sec,
+        params->timeout_nsec);
+  }
+  pthread_exit(NULL);
+}
+
+/** get a SyncBarrier, register as emitter and emit */
+void * start_barrier_emitter_thread(void * data) {
+  waiter_thread_params *params = (waiter_thread_params *)data;
+  char *comp;
+  asprintf(&comp, "emitter %u", params->thread_nr);
+  string component = comp;
+  free(comp);
+  RefPtr<SyncPoint> sp;
+  EXPECT_NO_THROW(sp = params->manager->get_syncpoint(component, params->sp_identifier));
+  sp->register_emitter(component);
+  for (uint i = 0; i < params->num_wait_calls; i++) {
+    sp->emit(component);
+  }
+  pthread_exit(NULL);
+}
+
+/** Helper class which registers and emits a given SyncBarrier */
+class Emitter {
+public:
+  /** Constructor.
+   *  @param identifier The identifier of this emitter.
+   *  @param syncbarrier The identifier of the SyncBarrier to register for.
+   *  @param manager Pointer to the SyncPointManager to use.
+   */
+  Emitter(string identifier, string syncbarrier, RefPtr<SyncPointManager> manager)
+  : identifier_(identifier),
+    manager_(manager)
+  {
+    barrier_ = manager->get_syncpoint(identifier_, syncbarrier);
+    barrier_->register_emitter(identifier_);
+  }
+
+  /** Destructor. */
+  virtual ~Emitter()
+  {
+    barrier_->unregister_emitter(identifier_);
+    manager_->release_syncpoint(identifier_, barrier_);
+  }
+
+  /** emit the SyncBarrier */
+  void emit()
+  {
+    barrier_->emit(identifier_);
+  }
+
+private:
+  string identifier_;
+  RefPtr<SyncPoint> barrier_;
+  RefPtr<SyncPointManager> manager_;
+};
+
+
+/** Barrier: wait() returns immediately if no emitter is registered */
+TEST_F(SyncBarrierTest,WaitWithNoRegisteredEmitter)
+{
+  string barrier_id = "/test/barrier";
+  RefPtr<SyncPoint> barrier = manager->get_syncpoint("main loop", barrier_id);
+  const uint num_waiter_threads = 1;
+  const uint num_wait_calls = 1;
+  pthread_t waiter_threads[num_waiter_threads];
+  waiter_thread_params *params[num_waiter_threads];
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = num_wait_calls;
+    params[i]->sp_identifier = barrier_id;
+    pthread_create(&waiter_threads[i], &attrs, start_barrier_waiter_thread, params[i]);
+    usleep(10000);
+  }
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(waiter_threads[i], NULL));
+    delete params[i];
+  }
+}
+
+/** Start multiple threads, let them wait for a SyncBarrier,
+ *  also have two threads registered as emitter.
+ *  Let the first thread emit the barrier, assert the waiters did not unblock,
+ *  then let the second thread emit.
+ *  This tests the fundamental difference to a SyncPoint: With a SyncPoint,
+ *  wait() returns if the SyncPoint is emitted by one component.
+ *  With a SyncBarrier, all registered emitters need to emit the SyncBarrier
+ *  before wait() returns.
+ */
+TEST_F(SyncBarrierTest, WaitForAllEmitters)
+{
+
+  string barrier_id = "/test/barrier";
+  Emitter em1("emitter 1", barrier_id, manager);
+  Emitter em2("emitter 2", barrier_id, manager);
+
+  RefPtr<SyncPoint> barrier = manager->get_syncpoint("main loop", barrier_id);
+
+  const uint num_waiter_threads = 50;
+  const uint num_wait_calls = 1;
+  pthread_t waiter_threads[num_waiter_threads];
+  waiter_thread_params *params[num_waiter_threads];
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = num_wait_calls;
+    params[i]->sp_identifier = barrier_id;
+    pthread_create(&waiter_threads[i], &attrs, start_barrier_waiter_thread, params[i]);
+    usleep(10000);
+  }
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(waiter_threads[i], NULL));
+  }
+
+  em1.emit();
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(waiter_threads[i], NULL));
+  }
+
+  em1.emit();
+
+  em2.emit();
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(waiter_threads[i], NULL));
+    delete params[i];
+  }
+}
+
+
+/** two barriers, emit the first one. Only the threads waiting on the first
+ *  barrier should unblock
+ */
+TEST_F(SyncBarrierTest, BarriersAreIndependent)
+{
+  string barrier1_id = "/test/barrier1";
+  string barrier2_id = "/test/barrier2";
+  Emitter em1("em1", barrier1_id, manager);
+  Emitter em2("em2", barrier2_id, manager);
+
+  RefPtr<SyncPoint> barrier1 = manager->get_syncpoint("m1",
+    barrier1_id);
+
+  RefPtr<SyncPoint> barrier2 = manager->get_syncpoint("m2",
+    barrier2_id);
+
+  const uint num_waiter_threads = 50;
+  const uint num_wait_calls = 1;
+  pthread_t waiter_threads1[num_waiter_threads];
+  waiter_thread_params *params1[num_waiter_threads];
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    params1[i] = new waiter_thread_params();
+    params1[i]->manager = manager;
+    params1[i]->thread_nr = i;
+    params1[i]->num_wait_calls = num_wait_calls;
+    params1[i]->sp_identifier = barrier1_id;
+    pthread_create(&waiter_threads1[i], &attrs, start_barrier_waiter_thread,
+      params1[i]);
+    usleep(10000);
+  }
+
+  pthread_t waiter_threads2[num_waiter_threads];
+  waiter_thread_params *params2[num_waiter_threads];
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    params2[i] = new waiter_thread_params();
+    params2[i]->manager = manager;
+    params2[i]->thread_nr = num_waiter_threads + i;
+    params2[i]->num_wait_calls = num_wait_calls;
+    params2[i]->sp_identifier = barrier2_id;
+    pthread_create(&waiter_threads2[i], &attrs, start_barrier_waiter_thread,
+      params2[i]);
+    usleep(10000);
+  }
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(waiter_threads1[i], NULL));
+  }
+
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(waiter_threads2[i], NULL));
+  }
+
+  em1.emit();
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(waiter_threads1[i], NULL));
+    delete params1[i];
+  }
+
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(waiter_threads2[i], NULL));
+  }
+
+  em2.emit();
+
+  sleep(1);
+  for (uint i = 0; i < num_waiter_threads; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(waiter_threads2[i], NULL));
+    delete params2[i];
+  }
+}
+
+/**
+ * Test the SyncBarrier hierarchy, similar to the SyncPoint hierarchy test.
+ * This creates a SyncBarrier, an emitter and waiters which wait for the
+ * SyncBarrier's predecessor, the predecessor's predecessor (grandparent),
+ * and the root SyncBarrier ("/").
+ */
+TEST_F(SyncBarrierTest, SyncBarrierHierarchy)
+{
+  Emitter em1("emitter 1", "/test/topic/b1", manager);
+  Emitter em2("emitter 2", "/test/topic/b2", manager);
+  Emitter em3("emitter 3", "/other/topic", manager);
+
+  vector<string> identifiers = { "/test/topic", "/test", "/", "/other/topic" };
+  uint num_threads = identifiers.size();
+  pthread_t threads[num_threads];
+  waiter_thread_params *params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i] = new waiter_thread_params();
+    params[i]->manager = manager;
+    params[i]->thread_nr = i;
+    params[i]->num_wait_calls = 1;
+    params[i]->sp_identifier = identifiers.at(i);
+    pthread_create(&threads[i], &attrs, start_barrier_waiter_thread, params[i]);
+  }
+
+  usleep(10000);
+
+  for (uint i = 0; i < num_threads; i++) {
+    ASSERT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  em1.emit();
+  usleep(10000);
+  for (uint i = 0; i < num_threads; i++) {
+    ASSERT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  em2.emit();
+  usleep(10000);
+  /* The first waiters should be unblocked */
+  for (uint i = 0; i < num_threads - 2 ; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+    delete params[i];
+  }
+  /* The last two waiters should still be waiting */
+  for (uint i = num_threads - 2; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+    pthread_cancel(threads[i]);
+    ASSERT_EQ(0, pthread_join(threads[i], NULL));
+    delete params[i];
+  }
+}
+
+/** One component registers as emitter for two syncpoints, two other components
+ *  wait for the first and second syncpoint respectively.
+ *  Then, the first component unregisters for the first syncpoint.
+ *  Test whether it is still registered for the second syncpoint.
+ *  A third waiter waits for the predecessor syncpoint and should also still be
+ *  waiting after the emitter has unregistered for the first syncpoint.
+ */
+TEST_F(SyncPointManagerTest, OneEmitterRegistersForMultipleSyncPointsHierarchyTest)
+{
+  string id_sp1 = "/test/sp1";
+  string id_sp2 = "/test/sp2";
+  string id_sp_pred = "/test";
+  string id_emitter = "component_emitter";
+  string id_waiter1 = "component_waiter1";
+  string id_waiter2 = "component_waiter2";
+  string id_waiter3 = "component_waiter_on_predecessor";
+
+  RefPtr<SyncPoint> sp1 = manager->get_syncpoint(id_emitter, id_sp1);
+  RefPtr<SyncPoint> sp2 = manager->get_syncpoint(id_emitter, id_sp2);
+  manager->get_syncpoint(id_waiter1, id_sp1);
+  manager->get_syncpoint(id_waiter2, id_sp2);
+  RefPtr<SyncPoint> pred = manager->get_syncpoint(id_waiter3, id_sp_pred);
+  sp1->register_emitter(id_emitter);
+  sp2->register_emitter(id_emitter);
+  EXPECT_EQ(1, sp1->get_emitters().count(id_emitter));
+  EXPECT_EQ(1, sp2->get_emitters().count(id_emitter));
+  // this should be 2 as the emitter has registered twice
+  EXPECT_EQ(2, pred->get_emitters().count(id_emitter));
+
+
+  waiter_thread_params *params1 = new waiter_thread_params();
+  params1->manager = manager;
+  params1->component = id_waiter1;
+  params1->num_wait_calls = 1;
+  params1->sp_identifier = id_sp1;
+
+  waiter_thread_params *params2 = new waiter_thread_params();
+  params2->manager = manager;
+  params2->component = id_waiter2;
+  params2->num_wait_calls = 1;
+  params2->sp_identifier = id_sp2;
+
+  waiter_thread_params *params3 = new waiter_thread_params();
+  params3->manager = manager;
+  params3->component = id_waiter3;
+  params3->num_wait_calls = 1;
+  params3->sp_identifier = id_sp_pred;
+
+  pthread_t pthread1;
+  pthread_create(&pthread1, &attrs, start_barrier_waiter_thread, params1);
+  pthread_t pthread2;
+  pthread_create(&pthread2, &attrs, start_barrier_waiter_thread, params2);
+  pthread_t pthread3;
+  pthread_create(&pthread3, &attrs, start_barrier_waiter_thread, params3);
+
+  usleep(10000);
+  sp1->emit(id_emitter);
+  usleep(10000);
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread1, NULL));
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread2, NULL));
+  // this should be EBUSY as the component has registered twice for '/test'
+  // and thus should emit '/test' also twice (by hierarchical emit calls)
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread3, NULL));
+  sp2->emit(id_emitter);
+  usleep(10000);
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread2, NULL));
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread3, NULL));
+
+  sp2->unregister_emitter(id_emitter);
+  EXPECT_EQ(1, sp1->get_emitters().count(id_emitter));
+  EXPECT_EQ(0, sp2->get_emitters().count(id_emitter));
+  EXPECT_EQ(1, pred->get_emitters().count(id_emitter));
+
+  pthread_create(&pthread1, &attrs, start_barrier_waiter_thread, params1);
+  pthread_create(&pthread2, &attrs, start_barrier_waiter_thread, params2);
+  pthread_create(&pthread3, &attrs, start_barrier_waiter_thread, params3);
+
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread1, NULL));
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread2, NULL));
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread3, NULL));
+
+  sp1->emit(id_emitter);
+  usleep(10000);
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread1, NULL));
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread3, NULL));
+  delete params1;
+  delete params2;
+  delete params3;
+
+}
+
+/** Test if an exception is thrown if a registered emitter is currently not
+ * pending
+ */
+TEST_F(SyncBarrierTest, NonPendingEmitterEmits)
+{
+  Emitter em1("em1", "/barrier", manager);
+  // register a second emitter to avoid immediate reset after emit
+  Emitter em2("em2", "/barrier", manager);
+  EXPECT_NO_THROW(em1.emit());
+  EXPECT_NO_THROW(em1.emit());
+}
+
+/** Test if a component waiting for a syncpoint is woken up
+ * if an emitter is registered for two successor syncpoints and the emitter
+ * emits the same syncpoint twice
+ */
+TEST_F(SyncPointManagerTest, EmitterEmitsSameSyncPointTwiceTest)
+{
+  RefPtr<SyncPoint> sp1 = manager->get_syncpoint("emitter", "/test/sp1");
+  RefPtr<SyncPoint> sp2 = manager->get_syncpoint("emitter", "/test/sp2");
+  RefPtr<SyncPoint> sp_pred = manager->get_syncpoint("waiter", "/test");
+
+  sp1->register_emitter("emitter");
+  sp2->register_emitter("emitter");
+
+  waiter_thread_params *params1 = new waiter_thread_params();
+  params1->manager = manager;
+  params1->component = "waiter";
+  params1->num_wait_calls = 1;
+  params1->sp_identifier = "/test";
+
+  pthread_t pthread1;
+  pthread_create(&pthread1, &attrs, start_barrier_waiter_thread, params1);
+
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread1, NULL));
+
+  sp1->emit("emitter");
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread1, NULL));
+
+  sp1->emit("emitter");
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(pthread1, NULL));
+
+  sp2->emit("emitter");
+  usleep(10000);
+  ASSERT_EQ(0, pthread_tryjoin_np(pthread1, NULL));
+
+  delete params1;
+}
+
+
+/** helper function used for testing reltime_wait() */
+void * call_timed_wait(void *data)
+{
+  SyncPoint * sp = (SyncPoint *)(data);
+  sp->reltime_wait_for_all("waiter", 0, 1000000);
+  return NULL;
+}
+
+/** Test if the component returns when using reltime_wait */
+TEST_F(SyncPointManagerTest, RelTimeWaitTest)
+{
+  RefPtr<SyncPoint> sp1 = manager->get_syncpoint("emitter", "/test/sp1");
+  manager->get_syncpoint("waiter", "/test/sp1");
+  sp1->register_emitter("emitter");
+  pthread_t thread;
+  pthread_create(&thread, NULL, call_timed_wait, (void *) *sp1);
+  usleep(2000000);
+  ASSERT_EQ(0, pthread_tryjoin_np(thread, NULL));
+  /* The SyncPoint should have logged the error */
+  ASSERT_GT(cache_logger_->get_messages().size(), 0);
+
+}
+
+/// @cond INTERNALS
+struct emitter_thread_data {
+    RefPtr<SyncPointManager> manager;
+    std::string name;
+    std::string sp_name;
+};
+/// @endcond
+
+/** helper function to call emit in a thread */
+void * call_emit(void * data)
+{
+  emitter_thread_data * tdata = (emitter_thread_data *) data;
+  RefPtr<SyncPoint> sp = tdata->manager->get_syncpoint(tdata->name, tdata->sp_name);
+  sp->register_emitter(tdata->name);
+  sp->emit(tdata->name);
+  return NULL;
+}
+
+/** Test the functionality of lock_until_next_wait */
+TEST_F(SyncPointManagerTest, LockUntilNextWaitTest)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("component", "/test");
+
+  sp->lock_until_next_wait("component");
+  pthread_t thread;
+  emitter_thread_data * emitter_params = new emitter_thread_data();
+  emitter_params->manager = manager;
+  emitter_params->name = "emitter";
+  emitter_params->sp_name = "/test";
+  pthread_create(&thread, NULL, call_emit, (void *) emitter_params);
+
+  usleep(2000000);
+
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(thread, NULL));
+
+  pthread_t waiter_thread;
+  pthread_create(&waiter_thread, NULL, call_wait, (void *) *sp);
+
+  usleep(2000000);
+
+  ASSERT_EQ(0, pthread_tryjoin_np(thread, NULL));
+  ASSERT_EQ(0, pthread_tryjoin_np(waiter_thread, NULL));
+
+  delete emitter_params;
+}
+
+
+/** helper function used for testing wait() */
+void * call_wait_for_all(void *data)
+{
+  SyncPoint * sp = (SyncPoint *)(data);
+  sp->wait_for_all("waiter");
+  return NULL;
+}
+
+/** Test the functionality of lock_until_next_wait
+ *  Test whether the waiter really calls wait before ALL emitters call emit
+ *  This tests a potential race condition between wait() and emit() */
+TEST_F(SyncPointManagerTest, LockUntilNextWaitWaiterComesFirstTest)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("waiter", "/test");
+
+  sp->lock_until_next_wait("waiter");
+
+  uint num_emitters = 100;
+  pthread_t emitter_thread[num_emitters];
+  emitter_thread_data * params[num_emitters];
+  for (uint i = 0; i < num_emitters; i++) {
+    params[i] = new emitter_thread_data();
+    params[i]->manager = manager;
+    string emitter_name = "emitter" + to_string(i);
+    params[i]->name = emitter_name;
+    params[i]->sp_name = "/test";
+    pthread_create(&emitter_thread[i], NULL, call_emit, (void *) params[i]);
+  }
+
+  usleep(2000000);
+
+  for (uint i = 0; i < num_emitters; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(emitter_thread[i], NULL));
+  }
+
+  pthread_t waiter_thread;
+  pthread_create(&waiter_thread, NULL, call_wait_for_all, (void *) *sp);
+
+  usleep(2000000);
+
+  for (uint i = 0; i < num_emitters; i++) {
+    ASSERT_EQ(0, pthread_tryjoin_np(emitter_thread[i], NULL));
+    delete params[i];
+  }
+
+  ASSERT_EQ(0, pthread_tryjoin_np(waiter_thread, NULL));
+}
+
+/** Test whether all waiters are always released at the same time, even if one
+ *  waiter called wait after one emitter already emitted. In particular, this
+ *  tests the following scenario:
+ *  1. waiter1: wait
+ *  2. emitter1: emit
+ *  3. waiter2: wait
+ *  4. emitter2: emit
+ *  5. both waiter1 and waiter2 are released
+ */
+TEST_F(SyncPointManagerTest, WaitersAreAlwaysReleasedSimultaneouslyTest)
+{
+  string sp_identifier = "/test";
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter1", sp_identifier);
+  manager->get_syncpoint("emitter2", sp_identifier);
+  sp->register_emitter("emitter1");
+  sp->register_emitter("emitter2");
+  uint num_threads = 2;
+  pthread_t threads[num_threads];
+  waiter_thread_params params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i].manager = manager;
+    params[i].thread_nr = i;
+    params[i].num_wait_calls = 1;
+    params[i].sp_identifier = sp_identifier;
+  }
+  pthread_create(&threads[0], &attrs, start_barrier_waiter_thread, &params[0]);
+  pthread_yield();
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[0], NULL));
+  sp->emit("emitter1");
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[0], NULL));
+  pthread_create(&threads[1], &attrs, start_barrier_waiter_thread, &params[1]);
+  usleep(10000);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  sp->emit("emitter2");
+  usleep(10000);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+  }
+}
+
+/** Test whether all syncpoints are released simultaneously if a timeout occurs;
+ *  i.e. make sure that only the first waiter's timeout matters and all
+ *  subsequent waiters are released when the first waiter times out.
+ */
+TEST_F(SyncPointManagerTest, WaitersTimeoutSimultaneousReleaseTest)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter1", "/test");
+  sp->register_emitter("emitter1");
+  uint num_threads = 2;
+  pthread_t threads[num_threads];
+  string sp_identifier = "/test";
+  waiter_thread_params params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i].manager = manager;
+    params[i].thread_nr = i;
+    params[i].num_wait_calls = 1;
+    params[i].timeout_sec = 1;
+    params[i].sp_identifier = sp_identifier;
+  }
+  pthread_create(&threads[0], &attrs, start_barrier_waiter_thread, &params[0]);
+  pthread_yield();
+  usleep(10000);
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[0], NULL));
+  params[1].timeout_sec = 5;
+  pthread_create(&threads[1], &attrs, start_barrier_waiter_thread, &params[1]);
+  usleep(10000);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  sleep(2);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+  }
+}
+
+/** Similar as before, test if the timeout is handled properly. This time, let
+ *  a wait_for_one with a short timeout step by. The other waiters should not be
+ *  affected, i.e. they should still be waiting even when the timeout for the
+ *  wait_for_one occurred.
+ *  In other words, wait_for_one waiters are handled completeley separately.
+ */
+TEST_F(SyncPointManagerTest, WaitForOneSeparateTimeoutTest)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter1", "/test");
+  sp->register_emitter("emitter1");
+  string sp_identifier = "/test";
+  pthread_t wait_for_one_thread;
+  waiter_thread_params wait_for_one_params;
+  wait_for_one_params.manager = manager;
+  wait_for_one_params.thread_nr = 2;
+  wait_for_one_params.num_wait_calls = 1;
+  wait_for_one_params.timeout_sec = 0;
+  wait_for_one_params.timeout_nsec = 1000000;
+  wait_for_one_params.sp_identifier = sp_identifier;
+  pthread_create(&wait_for_one_thread, &attrs, start_waiter_thread,
+    &wait_for_one_params);
+  uint num_threads = 2;
+  pthread_t threads[num_threads];
+  waiter_thread_params params[num_threads];
+  for (uint i = 0; i < num_threads; i++) {
+    params[i].manager = manager;
+    params[i].thread_nr = i;
+    params[i].num_wait_calls = 1;
+    params[i].timeout_sec = 1;
+    params[i].sp_identifier = sp_identifier;
+    pthread_create(&threads[i], &attrs, start_barrier_waiter_thread,
+      &params[i]);
+  }
+  usleep(10);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  EXPECT_EQ(EBUSY, pthread_tryjoin_np(wait_for_one_thread, NULL));
+  usleep(2 * (uint)(wait_for_one_params.timeout_nsec / 1000));
+  EXPECT_EQ(0, pthread_tryjoin_np(wait_for_one_thread, NULL));
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(EBUSY, pthread_tryjoin_np(threads[i], NULL));
+  }
+  sleep(params[0].timeout_sec);
+  for (uint i = 0; i < num_threads; i++) {
+    EXPECT_EQ(0, pthread_tryjoin_np(threads[i], NULL));
+  }
+}
+
+TEST_F(SyncPointManagerTest, MultipleWaitsWithoutEmitters)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("waiter", "/test");
+  pthread_t waiter_thread;
+  waiter_thread_params thread_params;
+  thread_params.manager = manager;
+  thread_params.thread_nr = 1;
+  thread_params.num_wait_calls = 2;
+  thread_params.sp_identifier = "/test";
+  pthread_create(&waiter_thread, &attrs, start_barrier_waiter_thread,
+    &thread_params);
+  usleep(10000);
+  EXPECT_EQ(0, pthread_tryjoin_np(waiter_thread, NULL));
+}
+
+TEST_F(SyncPointManagerTest, ReleaseOfEmitterThrowsException)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter", "/test");
+  sp->register_emitter("emitter");
+  ASSERT_THROW(manager->release_syncpoint("emitter", sp),
+      SyncPointCannotReleaseEmitter);
+}
+
+TEST_F(SyncPointManagerTest, UnregisterNonEmitter)
+{
+  RefPtr<SyncPoint> sp = manager->get_syncpoint("emitter", "/test");
+  // "emitter" is a watcher but not an emitter
+  EXPECT_NO_THROW(sp->unregister_emitter("emitter"));
+  // "foo" is not known to the syncpoint
+  EXPECT_NO_THROW(sp->unregister_emitter("foo"));
+}
diff --git a/src/libs/tf/Makefile b/src/libs/tf/Makefile
index fa4e0d3f9..113119e33 100644
--- a/src/libs/tf/Makefile
+++ b/src/libs/tf/Makefile
@@ -33,7 +33,7 @@ OBJS_lua_fawkestf = fawkestf_tolua.o
 OBJS_all = $(OBJS_libfawkestf) $(OBJS_lua_fawkestf)
 
 ifeq ($(HAVE_TF),1)
-  CFLAGS  += $(CFLAGS_TF)
+  CFLAGS  += $(CFLAGS_TF) -O2
   LDFLAGS += $(LDFLAGS_TF)
   LIBS_all = $(LIBDIR)/libfawkestf.so
 
diff --git a/src/libs/tf/transform_listener.cpp b/src/libs/tf/transform_listener.cpp
index 041260956..77ff22438 100644
--- a/src/libs/tf/transform_listener.cpp
+++ b/src/libs/tf/transform_listener.cpp
@@ -77,10 +77,12 @@ namespace fawkes {
 /** Constructor.
  * @param bb blackboard to listen to
  * @param tf_transformer transformer to add transforms to
+ * @param bb_is_remote must be true if the blackboard is a RemoteBlackboard
  */
-TransformListener::TransformListener(BlackBoard *bb, Transformer *tf_transformer)
+TransformListener::TransformListener(BlackBoard *bb,
+    Transformer *tf_transformer, bool bb_is_remote)
   : BlackBoardInterfaceListener("TransformListener"),
-    bb_(bb), tf_transformer_(tf_transformer)
+    bb_(bb), tf_transformer_(tf_transformer), bb_is_remote_(bb_is_remote)
 {
   if (bb_) {
     tfifs_ = bb_->open_multiple_for_reading<TransformInterface>("/tf*");
@@ -88,6 +90,8 @@ TransformListener::TransformListener(BlackBoard *bb, Transformer *tf_transformer
     std::list<TransformInterface *>::iterator i;
     for (i = tfifs_.begin(); i != tfifs_.end(); ++i) {
       bbil_add_data_interface(*i);
+      // update data once we 
+      bb_interface_data_changed(*i);
     }
     bb_->register_listener(this);
 
@@ -129,6 +133,8 @@ TransformListener::bb_interface_created(const char *type, const char *id) throw(
     return;
   }
 
+  bb_interface_data_changed(tfif);
+
   try {
     bbil_add_data_interface(tfif);
     bb_->update_listener(this);
@@ -160,6 +166,9 @@ TransformListener::bb_interface_reader_removed(Interface *interface,
 void
 TransformListener::conditional_close(Interface *interface) throw()
 {
+  if (bb_is_remote_) {
+    return;
+  }
   // Verify it's a TransformInterface
   TransformInterface *tfif = dynamic_cast<TransformInterface *>(interface);
   if (! tfif) return;
@@ -188,7 +197,12 @@ TransformListener::bb_interface_data_changed(Interface *interface) throw()
 
   tfif->read();
 
-  std::string authority = tfif->writer();
+  std::string authority;
+  if (bb_is_remote_) {
+    authority = "remote";
+  } else {
+    std::string authority = tfif->writer();
+  }
   
   double *translation = tfif->translation();
   double *rotation = tfif->rotation();
@@ -196,13 +210,18 @@ TransformListener::bb_interface_data_changed(Interface *interface) throw()
   const std::string frame_id = tfif->frame();
   const std::string child_frame_id = tfif->child_frame();
 
-  Vector3 t(translation[0], translation[1], translation[2]);
-  Quaternion r(rotation[0], rotation[1], rotation[2], rotation[3]);
-  Transform tr(r, t);
+  try {
+    Vector3 t(translation[0], translation[1], translation[2]);
+    Quaternion r(rotation[0], rotation[1], rotation[2], rotation[3]);
+    assert_quaternion_valid(r);
+    Transform tr(r, t);
 
-  StampedTransform str(tr, *time, frame_id, child_frame_id);
+    StampedTransform str(tr, *time, frame_id, child_frame_id);
 
-  tf_transformer_->set_transform(str, authority, tfif->is_static_transform());
+    tf_transformer_->set_transform(str, authority, tfif->is_static_transform());
+  } catch (InvalidArgumentException &e) {
+    // ignore invalid, might just be not initialized, yet.
+  }
 }
 
 } // end namespace tf
diff --git a/src/libs/tf/transform_listener.h b/src/libs/tf/transform_listener.h
index a79942fc1..cc12e583a 100644
--- a/src/libs/tf/transform_listener.h
+++ b/src/libs/tf/transform_listener.h
@@ -77,7 +77,8 @@ class TransformListener
   public BlackBoardInterfaceListener
 {
  public:
-	TransformListener(BlackBoard *bb, Transformer *tf_transformer);
+	TransformListener(BlackBoard *bb, Transformer *tf_transformer,
+	    bool bb_is_remote=false);
   virtual ~TransformListener();
 
   // for BlackBoardInterfaceObserver
@@ -96,6 +97,7 @@ class TransformListener
  private:
   BlackBoard  *bb_;
   Transformer *tf_transformer_;
+  bool bb_is_remote_;
 
   std::list<TransformInterface *> tfifs_;
 };
diff --git a/src/plugins/Makefile b/src/plugins/Makefile
index fcbf069d2..b6cfe2143 100644
--- a/src/plugins/Makefile
+++ b/src/plugins/Makefile
@@ -26,9 +26,11 @@ SUBDIRS	= bbsync bblogger webview ttmainloop rrd rrdweb \
 	  static_transforms navgraph navgraph-clusters navgraph-generator colli \
 	  clips clips-agent clips-protobuf clips-webview clips-navgraph clips-ros \
 	  clips-tf openprs openprs-agent eclipse-clp \
-	  mongodb mongodb_log robot-memory clips-robot-memory pddl-robot-memory \
-	  openrave-robot-memory openni refboxcomm ros player xmlrpc gossip \
+	  mongodb mongodb_log \
+	  robot-memory clips-robot-memory pddl-robot-memory openrave-robot-memory \
+	  openni refboxcomm ros player xmlrpc gossip \
 	  robot_state_publisher gazebo dynamixel navgraph-interactive \
+	  syncpoint-test \
 	  pddl-planner clips-executive
 
 include $(BUILDSYSDIR)/rules.mk
diff --git a/src/plugins/clips-agent/clips_agent_thread.cpp b/src/plugins/clips-agent/clips_agent_thread.cpp
index 85f58b50a..4beafa1e5 100644
--- a/src/plugins/clips-agent/clips_agent_thread.cpp
+++ b/src/plugins/clips-agent/clips_agent_thread.cpp
@@ -232,12 +232,12 @@ ClipsAgentThread::loop()
 	if (as_info.skill_string == skiller_if_->skill_string()) {
 	  clips->assert_fact_f("(skill-update (name \"%s\") (status %s))", as_name.c_str(),
 			       status_string(skiller_if_->status()));
-	}
-	if (skiller_if_->status() == SkillerInterface::S_FINAL ||
-	    skiller_if_->status() == SkillerInterface::S_FAILED)
-	{
-	  finished_skills.push_back(as_name);
-	}
+	  if (skiller_if_->status() == SkillerInterface::S_FINAL ||
+              skiller_if_->status() == SkillerInterface::S_FAILED)
+	  {
+            finished_skills.push_back(as_name);
+          }
+        }
       }
     }
 
diff --git a/src/plugins/clips-executive/clips/blackboard-init.clp b/src/plugins/clips-executive/clips/blackboard-init.clp
index ed5c3224a..ee25bb3c8 100644
--- a/src/plugins/clips-executive/clips/blackboard-init.clp
+++ b/src/plugins/clips-executive/clips/blackboard-init.clp
@@ -1,7 +1,29 @@
+
+;---------------------------------------------------------------------------
+;  blackboard-init.clp - Initialize blackboard access
+;
+;  Created: Wed Sep 20 15:16:05 2017 +0200
+;  Copyright  2017  Tim Niemueller [www.niemueller.de]
+;  Licensed under GPLv2+ license, cf. LICENSE file
+;---------------------------------------------------------------------------
+
 ;load needed interfaces
-(defrule blackboard-init
+(defrule blackboard-enable-time-read
   "Prepare blackboard usage"
+  (declare (salience 1000))
   (ff-feature blackboard)
   =>
   (blackboard-enable-time-read)
 )
+
+(defrule blackboard-preload
+  "Preload configured blackboard interface types."
+  (declare (salience 1000))
+  (ff-feature blackboard)
+  (confval (path "/clips-executive/spec") (type STRING) (value ?spec))
+  (confval (path ?p&:(eq ?p (str-cat "/clips-executive/specs/" ?spec "/blackboard-preload")))
+					 (type STRING) (is-list TRUE) (list-value $?preload-types))
+  =>
+  (printout t "Pre-loading blackboard interface types: " ?preload-types crlf)
+  (foreach ?t ?preload-types (blackboard-preload ?t))
+)
diff --git a/src/plugins/clips-executive/clips/test-scenario/state-estimation.clp b/src/plugins/clips-executive/clips/test-scenario/state-estimation.clp
new file mode 100644
index 000000000..37463b1ef
--- /dev/null
+++ b/src/plugins/clips-executive/clips/test-scenario/state-estimation.clp
@@ -0,0 +1,7 @@
+;---------------------------------------------------------------------------
+;  state-estimation.clp - State Estimator Stub
+;
+;  Created: Wed 15 Nov 2017 23:24:25 CET
+;  Copyright  2017  Till Hofmann <hofmann@kbsg.rwth-aachen.de>
+;  Licensed under GPLv2+ license, cf. LICENSE file in the doc directory.
+;---------------------------------------------------------------------------
diff --git a/src/plugins/dynamixel/act_thread.cpp b/src/plugins/dynamixel/act_thread.cpp
index 06648a01f..3362cd4df 100644
--- a/src/plugins/dynamixel/act_thread.cpp
+++ b/src/plugins/dynamixel/act_thread.cpp
@@ -34,8 +34,8 @@ using namespace fawkes;
 
 /** Constructor. */
 DynamixelActThread::DynamixelActThread()
-  : Thread("DynamixelActThread", Thread::OPMODE_WAITFORWAKEUP),
-    BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_ACT_EXEC)
+  : Thread("DynamixelActThread", Thread::OPMODE_CONTINUOUS),
+    SyncPointAspect(SyncPoint::WAIT_FOR_ALL, "/sensors/acquire", "/act/exec/end")
 {
 }
 
diff --git a/src/plugins/dynamixel/act_thread.h b/src/plugins/dynamixel/act_thread.h
index da40365db..5fb0f9ebf 100644
--- a/src/plugins/dynamixel/act_thread.h
+++ b/src/plugins/dynamixel/act_thread.h
@@ -31,9 +31,9 @@ class DynamixelDriverThread;
 
 class DynamixelActThread
 : public fawkes::Thread,
-  public fawkes::BlockedTimingAspect,
   public fawkes::LoggingAspect,
-  public fawkes::ConfigurableAspect
+  public fawkes::ConfigurableAspect,
+  public fawkes::SyncPointAspect
 {
  public:
   DynamixelActThread();
diff --git a/src/plugins/dynamixel/driver_thread.cpp b/src/plugins/dynamixel/driver_thread.cpp
index 0e3ba93b9..077548b24 100644
--- a/src/plugins/dynamixel/driver_thread.cpp
+++ b/src/plugins/dynamixel/driver_thread.cpp
@@ -85,6 +85,7 @@ DynamixelDriverThread::init()
   cfg_min_voltage_                      = config->get_float((cfg_prefix_ + "min_voltage").c_str());
   cfg_max_voltage_                      = config->get_float((cfg_prefix_ + "max_voltage").c_str());
   cfg_servos_to_discover_               = config->get_uints((cfg_prefix_ + "servos").c_str());
+  cfg_enable_verbose_output_            = config->get_bool((cfg_prefix_ + "enable_verbose_output").c_str());
 
   chain_ = new DynamixelChain(cfg_device_.c_str(), cfg_read_timeout_ms_, cfg_enable_echo_fix_, cfg_enable_connection_stability_, cfg_min_voltage_, cfg_max_voltage_);
   DynamixelChain::DeviceList devl = chain_->discover(cfg_disc_timeout_ms_, cfg_servos_to_discover_);
@@ -244,6 +245,7 @@ DynamixelDriverThread::finalize()
 void
 DynamixelDriverThread::exec_sensor()
 {
+  logger->log_debug(name(), "start exec_sensor");
   if (has_fresh_data()) {
     for (auto &sp : servos_) {
       unsigned int servo_id = sp.first;
@@ -260,7 +262,9 @@ DynamixelDriverThread::exec_sensor()
 	angle = s.last_angle;
       }
 
+      logger->log_debug(name(), "try chain_r_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_, ScopedRWLock::LOCK_READ);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
 
       s.servo_if->set_timestamp(&s.time);
       s.servo_if->set_position(chain_->get_position(servo_id));
@@ -278,9 +282,9 @@ DynamixelDriverThread::exec_sensor()
       s.servo_if->set_velocity(get_velocity(servo_id));
       s.servo_if->set_alarm_shutdown(chain_->get_alarm_shutdown(servo_id));
       
-      if ((chain_->get_load(servo_id) & 0x3ff) > (cfg_prevent_alarm_shutdown_threshold_ * chain_->get_torque_limit(servo_id))) {
+      if (s.servo_if->is_enable_prevent_alarm_shutdown()) {
+        if ((chain_->get_load(servo_id) & 0x3ff) > (cfg_prevent_alarm_shutdown_threshold_ * chain_->get_torque_limit(servo_id))) {
         logger->log_warn(name(), "Servo with ID: %d is in overload condition: torque_limit: %d, load: %d", servo_id, chain_->get_torque_limit(servo_id), chain_->get_load(servo_id) & 0x3ff);
-        if (s.servo_if->is_enable_prevent_alarm_shutdown()) {
           // is the current load cw or ccw?
           if (chain_->get_load(servo_id) & 0x400) {
             goto_angle(servo_id, get_angle(servo_id) + 0.001);
@@ -308,6 +312,7 @@ DynamixelDriverThread::exec_sensor()
       s.joint_if->write();
     }
   }
+  logger->log_debug(name(), "end exec_sensor");
 }
 
 
@@ -315,6 +320,7 @@ DynamixelDriverThread::exec_sensor()
 void
 DynamixelDriverThread::exec_act()
 {
+  logger->log_debug(name(), "start exec_act");
   for (auto &sp : servos_) {
     unsigned int servo_id = sp.first;
     Servo &s = sp.second;
@@ -412,6 +418,7 @@ DynamixelDriverThread::exec_act()
     }
     if (write_led_if) s.led_if->write();
   }
+  logger->log_debug(name(), "end exec_act");
 }
 
 
@@ -430,11 +437,15 @@ DynamixelDriverThread::bb_interface_message_received(Interface *interface,
       return false; // do not enqueue StopMessage
     } else if (message->is_of_type<DynamixelServoInterface::FlushMessage>()) {
       stop_motion(si->first);
-      logger->log_info(name(), "Flushing message queue");
+      if (cfg_enable_verbose_output_) {
+        logger->log_info(name(), "Flushing message queue");
+      }
       si->second.servo_if->msgq_flush();
       return false;
     } else {
-      logger->log_info(name(), "Received message of type %s, enqueueing", message->type());
+      if (cfg_enable_verbose_output_) {
+        logger->log_info(name(), "Received message of type %s, enqueueing", message->type());
+      }
       return true;
     }
   }
@@ -680,7 +691,9 @@ DynamixelDriverThread::get_angle(unsigned int servo_id)
     return 0.;
   }
 
+  logger->log_debug(name(), "try chain_r_lock at line %d", __LINE__);
   ScopedRWLock lock(chain_rwlock_, ScopedRWLock::LOCK_READ);
+  logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
 
   int ticks  = ((int)chain_->get_position(servo_id)  - (int)DynamixelChain::CENTER_POSITION);
 
@@ -722,7 +735,9 @@ DynamixelDriverThread::is_final(unsigned int servo_id)
 
   float angle = get_angle(servo_id);
 
+  logger->log_debug(name(), "try chain_r_lock at line %d", __LINE__);
   ScopedRWLock lock(chain_rwlock_, ScopedRWLock::LOCK_READ);
+  logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
 
   return  ( (fabs(angle  - s.target_angle)  <= s.angle_margin) ||
 	    (! chain_->is_moving(servo_id)));
@@ -764,7 +779,9 @@ DynamixelDriverThread::loop()
       s.value_rwlock->lock_for_write();
       s.enable  = false;
       s.value_rwlock->unlock();
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
       chain_->set_led_enabled(servo_id, true);
       chain_->set_torque_enabled(servo_id, true);
       if (s.led_enable || s.led_disable || s.velo_pending || s.move_pending || s.mode_set_pending || s.recover_pending) usleep(3000);
@@ -772,7 +789,9 @@ DynamixelDriverThread::loop()
       s.value_rwlock->lock_for_write();
       s.disable = false;
       s.value_rwlock->unlock();
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
       chain_->set_torque_enabled(servo_id, false);
       if (s.led_enable || s.led_disable || s.velo_pending || s.move_pending || s.mode_set_pending || s.recover_pending) usleep(3000);
     }
@@ -781,15 +800,19 @@ DynamixelDriverThread::loop()
       s.value_rwlock->lock_for_write();
       s.led_enable = false;
       s.value_rwlock->unlock();    
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
       chain_->set_led_enabled(servo_id, true);
       if (s.velo_pending || s.move_pending || s.mode_set_pending || s.recover_pending) usleep(3000);
     } else if (s.led_disable) {
       s.value_rwlock->lock_for_write();
       s.led_disable = false;
       s.value_rwlock->unlock();    
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_);
-      chain_->set_led_enabled(servo_id, false);    
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
+      chain_->set_led_enabled(servo_id, false);
       if (s.velo_pending || s.move_pending || s.mode_set_pending || s.recover_pending) usleep(3000);
     }
 
@@ -798,7 +821,9 @@ DynamixelDriverThread::loop()
       s.velo_pending = false;
       unsigned int vel  = s.vel;
       s.value_rwlock->unlock();
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
       chain_->set_goal_speed(servo_id, vel);
       if (s.move_pending || s.mode_set_pending || s.recover_pending) usleep(3000);
     }
@@ -828,7 +853,9 @@ DynamixelDriverThread::loop()
     }
 
     try {
+      logger->log_debug(name(), "try chain_r_lock at line %d", __LINE__);
       ScopedRWLock lock(chain_rwlock_, ScopedRWLock::LOCK_READ);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
       chain_->read_table_values(servo_id);
 
       MutexLocker lock_fresh_data(fresh_data_mutex_);
@@ -866,7 +893,9 @@ DynamixelDriverThread::exec_goto_angle(unsigned int servo_id, float angle_rad)
     return;
   }
 
+  logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
   ScopedRWLock lock(chain_rwlock_);
+  logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
   chain_->goto_position(servo_id, pos);
 }
 
@@ -878,11 +907,15 @@ void
 DynamixelDriverThread::exec_set_mode(unsigned int servo_id, unsigned int new_mode)
 {
   if (new_mode == DynamixelServoInterface::JOINT) {
-    ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
+      ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
     chain_->set_angle_limits(servo_id, 0, 1023);
   }
   else if (new_mode == DynamixelServoInterface::WHEEL) {
-    ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "try chain_w_lock at line %d", __LINE__);
+      ScopedRWLock lock(chain_rwlock_);
+      logger->log_debug(name(), "lock succeed     at line %d", __LINE__);
     chain_->set_angle_limits(servo_id, 0, 0);
   }
   else {
diff --git a/src/plugins/dynamixel/driver_thread.h b/src/plugins/dynamixel/driver_thread.h
index 92690471e..a125a7736 100644
--- a/src/plugins/dynamixel/driver_thread.h
+++ b/src/plugins/dynamixel/driver_thread.h
@@ -129,6 +129,7 @@ class DynamixelDriverThread
   float         cfg_min_voltage_;
   float         cfg_max_voltage_;
   std::vector<unsigned int> cfg_servos_to_discover_;
+  bool          cfg_enable_verbose_output_;
   
   void  goto_angle(unsigned int servo_id, float angle);
   void  goto_angle_timed(unsigned int servo_id, float angle, float time_sec);
diff --git a/src/plugins/joystick/acquisition_thread.cpp b/src/plugins/joystick/acquisition_thread.cpp
index 8c0876e88..85c9399f7 100644
--- a/src/plugins/joystick/acquisition_thread.cpp
+++ b/src/plugins/joystick/acquisition_thread.cpp
@@ -84,6 +84,7 @@ JoystickAcquisitionThread::JoystickAcquisitionThread(const char *device_file,
   ff_ = NULL;
   bbhandler_ = handler;
   this->logger = logger;
+  safety_lockout_ = true;
   init(device_file);
 }
 
@@ -93,6 +94,7 @@ JoystickAcquisitionThread::init()
 {
   try {
     cfg_device_file_    = config->get_string("/hardware/joystick/device_file");
+    cfg_retry_interval_ = config->get_float("/hardware/joystick/retry_interval");
   } catch (Exception &e) {
     e.append("Could not read all required config values for %s", name());
     throw;
@@ -112,8 +114,24 @@ JoystickAcquisitionThread::init()
   }
   for (int i = 0; i < 5; ++i) safety_combo_[i] = false;
 
-  init(cfg_device_file_);
+  cfg_lazy_init_ = false;
+  try {
+	  cfg_lazy_init_ = config->get_bool("/hardware/joystick/allow_deferred_initialization");
+  } catch (Exception &e) {} // ignore, use default
 
+  try {
+	  init(cfg_device_file_, cfg_lazy_init_);
+  } catch (Exception &e) {
+		if (! cfg_lazy_init_) {
+			e.append("Deferred initialization of joystick device disabled");
+		}
+		throw;
+  }
+
+  if (! connected_ && cfg_lazy_init_) {
+	  logger->log_info(name(), "Cannot open joystick, deferred initialization enabled");
+  }
+  
   if (safety_lockout_) {
 	  logger->log_info(name(), "To enable joystick, move primary cross all the way in all "
 	                   "directions while holding first button. Then let go of button.");
@@ -190,19 +208,26 @@ JoystickAcquisitionThread::open_forcefeedback()
 }
 
 void
-JoystickAcquisitionThread::init(std::string device_file)
+JoystickAcquisitionThread::init(std::string device_file, bool allow_open_fail)
 {
-  new_data_ = false;
+	fd_ = -1;
+	connected_ = false;
+	just_connected_ = false;
+	new_data_ = false;
+
   cfg_device_file_ = device_file;
-  open_joystick();
   try {
-    open_forcefeedback();
+	  open_joystick();
+	  try {
+		  open_forcefeedback();
+	  } catch (Exception &e) {
+		  logger->log_warn(name(), "Initializing force feedback failed, disabling");
+		  logger->log_warn(name(), e);
+	  }
   } catch (Exception &e) {
-    logger->log_warn(name(), "Initializing force feedback failed, disabling");
-    logger->log_warn(name(), e);
+	  if (! allow_open_fail) throw;
   }
   data_mutex_ = new Mutex();
-
 }
 
 
@@ -337,19 +362,20 @@ JoystickAcquisitionThread::loop()
 		    bbhandler_->joystick_changed(pressed_buttons_, axis_values_);
 	    }
     }
-  } else {
-    // Connection to joystick has been lost
-    try {
-      open_joystick();
-      logger->log_warn(name(), "Joystick plugged in. Delivering data again.");
-      try {
-	open_forcefeedback();
-      } catch (Exception &e) {
-	logger->log_warn(name(), "Initializing force feedback failed, disabling");
-      }
-    } catch (Exception &e) {
-	    usleep(100000);
-    }
+	} else {
+		// Connection to joystick has been lost
+		try {
+			open_joystick();
+			logger->log_warn(name(), "Joystick plugged in. Delivering data again.");
+			try {
+				open_forcefeedback();
+			} catch (Exception &e) {
+				logger->log_warn(name(), "Initializing force feedback failed, disabling");
+			}
+		} catch (Exception &e) {
+			Time duration(cfg_retry_interval_);
+			duration.wait_systime();
+		}
   }
 }
 
diff --git a/src/plugins/joystick/acquisition_thread.h b/src/plugins/joystick/acquisition_thread.h
index 537360e58..90f566505 100644
--- a/src/plugins/joystick/acquisition_thread.h
+++ b/src/plugins/joystick/acquisition_thread.h
@@ -72,12 +72,14 @@ class JoystickAcquisitionThread
  protected: virtual void run() { Thread::run(); }
 
  private:
-  void init(std::string device_file);
+  void init(std::string device_file, bool allow_open_fail = false);
   void open_joystick();
   void open_forcefeedback();
   
  private:
   std::string  cfg_device_file_;
+  float        cfg_retry_interval_;
+  bool         cfg_lazy_init_;
   float        cfg_safety_lockout_timeout_;
   unsigned int cfg_safety_button_mask_;
   unsigned int cfg_safety_bypass_button_mask_;
diff --git a/src/plugins/joystick/joystick_teleop_thread.cpp b/src/plugins/joystick/joystick_teleop_thread.cpp
index 0e63a7d5f..88e043af0 100644
--- a/src/plugins/joystick/joystick_teleop_thread.cpp
+++ b/src/plugins/joystick/joystick_teleop_thread.cpp
@@ -227,22 +227,30 @@ JoystickTeleOpThread::loop()
              ! runstop_pressed_ &&
              motor_if_->motor_state() != MotorInterface::MOTOR_DISABLED)
   {
-	  stop();
-	  MotorInterface::SetMotorStateMessage *msg =
-		  new MotorInterface::SetMotorStateMessage(MotorInterface::MOTOR_DISABLED);
-	  motor_if_->msgq_enqueue(msg);
-	  logger->log_warn(name(), "Runstop ENABLED");
-	  runstop_pressed_ = true;
+	  try {
+		  stop();
+		  MotorInterface::SetMotorStateMessage *msg =
+			  new MotorInterface::SetMotorStateMessage(MotorInterface::MOTOR_DISABLED);
+		  motor_if_->msgq_enqueue(msg);
+		  runstop_pressed_ = true;
+		  logger->log_warn(name(), "Runstop ENABLED");
+	  } catch (Exception &e) {
+		  logger->log_error(name(), "FAILED to enable runstop: %s", e.what_no_backtrace());
+	  }
   } else if (joystick_if_->pressed_buttons() == cfg_runstop_disable_buttons_ &&
              ! runstop_pressed_ &&
              motor_if_->motor_state() == MotorInterface::MOTOR_DISABLED)
   {
-	  stop();
-	  MotorInterface::SetMotorStateMessage *msg =
-		  new MotorInterface::SetMotorStateMessage(MotorInterface::MOTOR_ENABLED);
-	  motor_if_->msgq_enqueue(msg);
-	  logger->log_warn(name(), "Runstop DISABLED");
-	  runstop_pressed_ = true;
+	  try {
+		  stop();
+		  MotorInterface::SetMotorStateMessage *msg =
+			  new MotorInterface::SetMotorStateMessage(MotorInterface::MOTOR_ENABLED);
+		  motor_if_->msgq_enqueue(msg);
+		  logger->log_warn(name(), "Runstop DISABLED");
+		  runstop_pressed_ = true;
+	  } catch (Exception &e) {
+		  logger->log_error(name(), "FAILED to enable runstop: %s", e.what_no_backtrace());
+	  }
   } else if ((joystick_if_->pressed_buttons() & cfg_deadman_butmask_) ||
 	     (cfg_deadman_use_axis_ &&
 	      ((cfg_deadman_ax_thresh_ >= 0 && joystick_if_->axis(cfg_deadman_axis_) > cfg_deadman_ax_thresh_) ||
diff --git a/src/plugins/laser/sick_tim55x_common_aqt.cpp b/src/plugins/laser/sick_tim55x_common_aqt.cpp
index e4f6cb42d..a51210a8c 100644
--- a/src/plugins/laser/sick_tim55x_common_aqt.cpp
+++ b/src/plugins/laser/sick_tim55x_common_aqt.cpp
@@ -103,15 +103,18 @@ SickTiM55xCommonAcquisitionThread::pre_init(fawkes::Configuration *config,
 
   if (dev_model_ == "TiM5xx") {
     _distances_size = 360;
+    _echoes_size = 360;
     expected_num_data_ = 271;
   } else if (dev_model_ == "TiM571") {
     _distances_size = 1080;
+    _echoes_size = 1080;
     expected_num_data_ = 811;
   } else {
     throw Exception("LaserSick5xx: unknown model %s", dev_model_.c_str());
   }
 
   alloc_distances(_distances_size);
+  alloc_echoes(_echoes_size);
 
   config->add_change_handler(this);
 }
diff --git a/src/plugins/laser/sick_tim55x_ethernet_aqt.cpp b/src/plugins/laser/sick_tim55x_ethernet_aqt.cpp
index a140c7210..e11ea78d1 100644
--- a/src/plugins/laser/sick_tim55x_ethernet_aqt.cpp
+++ b/src/plugins/laser/sick_tim55x_ethernet_aqt.cpp
@@ -90,6 +90,9 @@ SickTiM55xEthernetAcquisitionThread::finalize()
   free(_distances);
   _distances = NULL;
 
+  free(_echoes);
+  _echoes = NULL;
+
   delete socket_mutex_;
 }
 
diff --git a/src/plugins/laser/sick_tim55x_usb_aqt.cpp b/src/plugins/laser/sick_tim55x_usb_aqt.cpp
index 45b8531cd..538bd353f 100644
--- a/src/plugins/laser/sick_tim55x_usb_aqt.cpp
+++ b/src/plugins/laser/sick_tim55x_usb_aqt.cpp
@@ -117,6 +117,9 @@ SickTiM55xUSBAcquisitionThread::finalize()
   free(_distances);
   _distances = NULL;
 
+  free(_echoes);
+  _echoes = NULL;
+
   delete usb_mutex_;
 }
 
diff --git a/src/plugins/navgraph/navgraph_thread.cpp b/src/plugins/navgraph/navgraph_thread.cpp
index 4fb6c4521..6c0531129 100644
--- a/src/plugins/navgraph/navgraph_thread.cpp
+++ b/src/plugins/navgraph/navgraph_thread.cpp
@@ -177,6 +177,7 @@ NavGraphThread::init()
   last_node_         = "";
   error_reason_      = "";
   constrained_plan_  = false;
+  cmd_msgid_         = 0;
   cmd_sent_at_       = new Time(clock);
   path_planned_at_   = new Time(clock);
   target_reached_at_ = new Time(clock);
@@ -233,10 +234,16 @@ NavGraphThread::loop()
 
     if (pp_nav_if_->msgq_first_is<NavigatorInterface::StopMessage>()) {
       NavigatorInterface::StopMessage *msg = pp_nav_if_->msgq_first(msg);
-      pp_nav_if_->set_msgid(msg->id());
+      if (msg->msgid() == 0 || msg->msgid() == pp_nav_if_->msgid()) {
+	      NavigatorInterface::StopMessage *msg = pp_nav_if_->msgq_first(msg);
+	      pp_nav_if_->set_msgid(msg->id());
 
-      stop_motion();
-      exec_active_ = false;
+	      stop_motion();
+	      exec_active_ = false;
+      } else {
+	      logger->log_warn(name(), "Received stop message for non-active command "
+	                       "(got %u, running %u)", msg->msgid(), pp_nav_if_->msgid());
+      }
 
     } else if (pp_nav_if_->msgq_first_is<NavigatorInterface::CartesianGotoMessage>()) {
       NavigatorInterface::CartesianGotoMessage *msg = pp_nav_if_->msgq_first(msg);
@@ -715,7 +722,7 @@ NavGraphThread::stop_motion()
 {
 	if (! cfg_enable_path_execution_)  return;
 
-  NavigatorInterface::StopMessage *stop = new NavigatorInterface::StopMessage();
+  NavigatorInterface::StopMessage *stop = new NavigatorInterface::StopMessage(cmd_msgid_);
   try {
     nav_if_->msgq_enqueue(stop);
   } catch (Exception &e) {
@@ -728,6 +735,7 @@ NavGraphThread::stop_motion()
   target_rotating_ = false;
   pp_nav_if_->set_final(true);
   traversal_.invalidate();
+  cmd_msgid_ = 0;
 
 #ifdef HAVE_VISUALIZATION
   if (vt_) {
@@ -796,8 +804,8 @@ NavGraphThread::send_next_goal()
 
   NavigatorInterface::CartesianGotoMessage *gotomsg =
     new NavigatorInterface::CartesianGotoMessage(tpose.getOrigin().x(),
-						 tpose.getOrigin().y(),
-						 tf::get_yaw(tpose.getRotation()));
+                                                 tpose.getOrigin().y(),
+                                                 tf::get_yaw(tpose.getRotation()));
 
   NavigatorInterface::SetStopAtTargetMessage* stop_at_target_msg      = new NavigatorInterface::SetStopAtTargetMessage(stop_at_target);
   NavigatorInterface::SetOrientationModeMessage* orient_mode_msg;
@@ -826,6 +834,7 @@ NavGraphThread::send_next_goal()
 		      tf::get_yaw(tpose.getRotation()), next_target.name().c_str());
 
     nav_if_->msgq_enqueue(gotomsg);
+    cmd_msgid_ = gotomsg->id();
     cmd_sent_at_->stamp();
 
     error_at_->stamp();
diff --git a/src/plugins/navgraph/navgraph_thread.h b/src/plugins/navgraph/navgraph_thread.h
index 74c13a4a5..357ad3673 100644
--- a/src/plugins/navgraph/navgraph_thread.h
+++ b/src/plugins/navgraph/navgraph_thread.h
@@ -135,6 +135,7 @@ class NavGraphThread
 
   fawkes::LockPtr<fawkes::NavGraphConstraintRepo> constraint_repo_;
 
+  unsigned int  cmd_msgid_;
   fawkes::Time *cmd_sent_at_;
   fawkes::Time *path_planned_at_;
 
diff --git a/src/plugins/pddl-robot-memory/pddl_robot_memory_thread.cpp b/src/plugins/pddl-robot-memory/pddl_robot_memory_thread.cpp
index 661f376fd..f288b1bc4 100644
--- a/src/plugins/pddl-robot-memory/pddl_robot_memory_thread.cpp
+++ b/src/plugins/pddl-robot-memory/pddl_robot_memory_thread.cpp
@@ -157,7 +157,7 @@ PddlRobotMemoryThread::loop()
     std::vector<std::string> error_list = ctemplate::TemplateNamelist::GetBadSyntaxList(false, ctemplate::DO_NOT_STRIP);
     for(std::string error : error_list)
     {
-      logger->log_error(name(), "", error.c_str());
+      logger->log_error(name(), "%s", error.c_str());
     }
   }
   //Let ctemplate expand the input
diff --git a/src/plugins/realsense/Makefile b/src/plugins/realsense/Makefile
index f9afe826f..fdac2ed0e 100644
--- a/src/plugins/realsense/Makefile
+++ b/src/plugins/realsense/Makefile
@@ -25,7 +25,7 @@ LDFLAGS += $(LDFLAGS_TF) $(LDFLAGS_PCL)
 
 LIBS_realsense = m fawkescore fawkesutils fawkesaspects fawkesbaseapp \
                       fawkesblackboard fawkesinterface realsense \
-                      fawkespcl_utils
+                      fawkespcl_utils SwitchInterface
 
 OBJS_realsense = realsense_plugin.o realsense_thread.o 
 
diff --git a/src/plugins/ros/navigator_thread.cpp b/src/plugins/ros/navigator_thread.cpp
index 3066a4027..446b8bd3c 100644
--- a/src/plugins/ros/navigator_thread.cpp
+++ b/src/plugins/ros/navigator_thread.cpp
@@ -54,7 +54,6 @@ RosNavigatorThread::init()
   //tell the action client that we want to spin a thread by default
   ac_ = new MoveBaseClient("move_base", false);
 
-  logger->log_error(name(),"Change Interface (x,y) ");
   cmd_sent_ = false;
   connected_history_ = false;
   nav_if_->set_final(true);
@@ -236,15 +235,20 @@ RosNavigatorThread::loop()
 
       // stop
       if (NavigatorInterface::StopMessage *msg = nav_if_->msgq_first_safe(msg)) {
-        logger->log_info(name(), "Stop message received");
-        nav_if_->set_dest_x(0);
-        nav_if_->set_dest_y(0);
-        nav_if_->set_dest_ori(0);
-
-        nav_if_->set_msgid(msg->id());
-        nav_if_->write();
-
-        stop_goals();
+	      if (msg->msgid() == 0 || msg->msgid() == nav_if_->msgid()) {
+		      logger->log_info(name(), "Stop message received");
+		      nav_if_->set_dest_x(0);
+		      nav_if_->set_dest_y(0);
+		      nav_if_->set_dest_ori(0);
+
+		      nav_if_->set_msgid(msg->id());
+		      nav_if_->write();
+
+		      stop_goals();
+	      } else {
+		      logger->log_warn(name(), "Received stop message for non-active command "
+		                       "(got %u, running %u)", msg->msgid(), nav_if_->msgid());
+	      }
       }
 
       // cartesian goto
diff --git a/src/plugins/syncpoint-test/Makefile b/src/plugins/syncpoint-test/Makefile
new file mode 100644
index 000000000..156fdc107
--- /dev/null
+++ b/src/plugins/syncpoint-test/Makefile
@@ -0,0 +1,32 @@
+#*****************************************************************************
+#               Makefile Build System for Fawkes: SyncPoint Test Plugin
+#
+#   Created on Wed Mar 04 17:57:42 2015
+#   Copyright (C) 2015 by Till Hofmann
+#
+##*****************************************************************************
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#*****************************************************************************
+
+BASEDIR = ../../..
+
+include $(BASEDIR)/etc/buildsys/config.mk
+
+DISABLE_OBJS_all_WARNING=1
+
+LIBS_syncpoint_test = fawkescore fawkesutils fawkesaspects
+OBJS_syncpoint_test = test_plugin.o test_thread.o
+
+OBJS_test    = $(OBJS_syncpoint_test)
+
+PLUGINS_test = $(PLUGINDIR)/syncpoint-test.$(SOEXT)
+
+CFLAGS += $(CFLAGS_CPP11)
+
+
+include $(BUILDSYSDIR)/base.mk
diff --git a/src/plugins/syncpoint-test/test_plugin.cpp b/src/plugins/syncpoint-test/test_plugin.cpp
new file mode 100644
index 000000000..fb3df987c
--- /dev/null
+++ b/src/plugins/syncpoint-test/test_plugin.cpp
@@ -0,0 +1,70 @@
+/***************************************************************************
+ *  test_plugin.cpp - SyncPoint Test plugin
+ *
+ *  Created: Wed Mar 04 17:57:42 2015
+ *  Copyright  2015  Till Hofmann
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <core/plugin.h>
+#include "test_thread.h"
+#include <aspect/blocked_timing.h>
+#include <vector>
+#include <algorithm>
+
+using namespace fawkes;
+
+/** Plugin to test syncpoints
+ * @author Till Hofmann
+ */
+class SyncPointTestPlugin : public fawkes::Plugin
+{
+ public:
+  /** Constructor.
+   * @param config Fawkes configuration
+   */
+    SyncPointTestPlugin(Configuration *config)
+    : Plugin(config)
+  {
+      std::vector<BlockedTimingAspect::WakeupHook> hooks;
+      hooks = {
+          BlockedTimingAspect::WAKEUP_HOOK_PRE_LOOP, /**< before each loop */
+          BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE, /**< sensor acquisition thread,
+                                       *  acquire data from sensor */
+          BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PREPARE, /**< sensor data preparation thread,
+                                       * convert acquired data to usable format */
+          BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS, /**< sensor data processing thread */
+          BlockedTimingAspect::WAKEUP_HOOK_WORLDSTATE, /**< world state thread */
+          BlockedTimingAspect::WAKEUP_HOOK_THINK,    /**< think thread (agent) */
+          BlockedTimingAspect::WAKEUP_HOOK_SKILL,    /**< skill thread (skill module) */
+          BlockedTimingAspect::WAKEUP_HOOK_ACT,    /**< act thread (motor module etc.) */
+          BlockedTimingAspect::WAKEUP_HOOK_ACT_EXEC, /**< act execution thread */
+          BlockedTimingAspect::WAKEUP_HOOK_POST_LOOP /**< run after loop */
+      };
+
+      for (std::vector<BlockedTimingAspect::WakeupHook>::iterator it = hooks.begin();
+          it != hooks.end(); it++) {
+        std::string name = "SyncPointTestThread-";
+        std::string hook_name = BlockedTimingAspect::blocked_timing_hook_to_string(*it);
+        std::transform(hook_name.begin(), hook_name.end(), hook_name.begin(), ::tolower);
+        name.append(hook_name);
+        thread_list.push_back(new SyncPointTestThread(name.c_str(), *it));
+      }
+  }
+};
+
+PLUGIN_DESCRIPTION("Plugin to test SyncPoints and the BlockedTimingAspect")
+EXPORT_PLUGIN(SyncPointTestPlugin)
+
diff --git a/src/plugins/syncpoint-test/test_thread.cpp b/src/plugins/syncpoint-test/test_thread.cpp
new file mode 100644
index 000000000..36f2dc6ab
--- /dev/null
+++ b/src/plugins/syncpoint-test/test_thread.cpp
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *  test_thread.cpp - Thread to test SyncPoints
+ *
+ *  Created: Thu Mar 05 15:15:42 2015
+ *  Copyright  2015  Till Hofmann
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include "test_thread.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+using namespace fawkes;
+
+/** @class SyncPointTestThread "test_thread.h"
+ * Thread to test SyncPoints.
+ * This thread has the blocked timing aspect and belongs to a wakeup hook.
+ * It simply prints its name.
+ * @author Till Hofmann
+ */
+
+/** Constructor.
+ *  @param name the name of the thread
+ *  @param hook the hook this thread belongs to
+ */
+
+SyncPointTestThread::SyncPointTestThread(const char * name, BlockedTimingAspect::WakeupHook hook)
+  : Thread(name, Thread::OPMODE_WAITFORWAKEUP),
+    BlockedTimingAspect(hook),
+    hook_(hook)
+{
+}
+
+void
+SyncPointTestThread::init()
+{
+}
+
+void
+SyncPointTestThread::finalize()
+{
+}
+
+void
+SyncPointTestThread::loop()
+{
+  usleep(random() % 100000);
+  logger->log_info("SyncPointTestThread", "In hook %s", BlockedTimingAspect::blocked_timing_hook_to_string(hook_));
+}
diff --git a/src/plugins/syncpoint-test/test_thread.h b/src/plugins/syncpoint-test/test_thread.h
new file mode 100644
index 000000000..a66a628ba
--- /dev/null
+++ b/src/plugins/syncpoint-test/test_thread.h
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *  test_thread.h - Thread to test SyncPoints
+ *
+ *  Created: Thu Mar 05 15:15:42 2015
+ *  Copyright  2015  Till Hofmann
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __PLUGINS_SYNCPOINT_TEST_THREAD_H_
+#define __PLUGINS_SYNCPOINT_TEST_THREAD_H_
+
+#include <core/threading/thread.h>
+#include <aspect/logging.h>
+#include <aspect/blocked_timing.h>
+
+class SyncPointTestThread
+: public fawkes::Thread,
+  public fawkes::LoggingAspect,
+  public fawkes::BlockedTimingAspect
+{
+ public:
+    SyncPointTestThread(const char * name, BlockedTimingAspect::WakeupHook hook);
+
+  virtual void init();
+  virtual void loop();
+  virtual void finalize();
+
+ private:
+  BlockedTimingAspect::WakeupHook hook_;
+};
+
+#endif
diff --git a/src/plugins/webview/Makefile b/src/plugins/webview/Makefile
index cf5b1acd1..cda8fd5c4 100644
--- a/src/plugins/webview/Makefile
+++ b/src/plugins/webview/Makefile
@@ -94,6 +94,16 @@ ifeq ($(HAVE_LIBMICROHTTPD),1)
     LIBS_webview += crypt
     WARN_TARGETS += warning_apr_util
   endif
+
+  ifeq ($(HAVE_GRAPHVIZ),1)
+    OBJS_webview += syncpoint_processor.o
+    LIBS_webview += fawkessyncpoint
+    CFLAGS += $(CFLAGS_GRAPHVIZ)
+    LDFLAGS += $(LDFLAGS_GRAPHVIZ)
+  else
+    WARN_TARGETS += warning_graphviz
+  endif
+
 else
   WARN_TARGETS += warning_libmicrohttpd
 endif
@@ -110,7 +120,7 @@ warning_libmicrohttpd:
 warning_tf:
 	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting transforms support$(TNORMAL) (TF not available)"
 warning_graphviz:
-	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting transforms support$(TNORMAL) (graphviz not found)"
+	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting transforms and syncpoint support$(TNORMAL) (graphviz not found)"
 warning_jpeg:
 	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting image viewing support$(TNORMAL) (JPEG not available)"
 warning_cpp11:
diff --git a/src/plugins/webview/syncpoint_processor.cpp b/src/plugins/webview/syncpoint_processor.cpp
new file mode 100644
index 000000000..140c54ad0
--- /dev/null
+++ b/src/plugins/webview/syncpoint_processor.cpp
@@ -0,0 +1,259 @@
+
+/***************************************************************************
+ *  syncpoint_processor.cpp - Web request processor for SyncPoints
+ *
+ *  Created: Thu Aug 14 16:21:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include "syncpoint_processor.h"
+#include <webview/page_reply.h>
+#include <webview/file_reply.h>
+#include <webview/error_reply.h>
+
+#include <syncpoint/syncpoint_call_stats.h>
+#include <aspect/blocked_timing.h>
+
+#include <string>
+#include <sstream>
+#include <cstring>
+#include <cstdlib>
+#include <cerrno>
+
+#include <gvc.h>
+#include <gvcjob.h>
+
+using namespace fawkes;
+
+/** @class WebviewSyncPointRequestProcessor "tf_processor.h"
+ * SyncPoint web request processor.
+ * Visualizes SyncPoints.
+ * @author Till Hofmann
+ */
+
+/** Constructor.
+ * @param baseurl Base URL where processor is mounted
+ * @param syncpoint_manager SyncPointManager which manages all SyncPoints
+ * @param max_age Show only SyncPoint calls which are younger than max_age
+ */
+WebviewSyncPointRequestProcessor::WebviewSyncPointRequestProcessor(const char *baseurl,
+  fawkes::SyncPointManager *syncpoint_manager, float max_age)
+{
+  baseurl_     = strdup(baseurl);
+  baseurl_len_ = strlen(baseurl_);
+  syncpoint_manager_ = syncpoint_manager;
+  max_age_     = max_age;
+}
+
+
+/** Destructor. */
+WebviewSyncPointRequestProcessor::~WebviewSyncPointRequestProcessor()
+{
+  free(baseurl_);
+}
+
+
+WebReply *
+WebviewSyncPointRequestProcessor::process_request(const fawkes::WebRequest *request)
+{
+  if ( strncmp(baseurl_, request->url().c_str(), baseurl_len_) == 0 ) {
+    // It is in our URL prefix range
+    std::string subpath = request->url().substr(baseurl_len_);
+
+    if (subpath == "/graph.png") {
+      std::string graph = all_syncpoints_as_dot(
+        syncpoint_manager_->get_syncpoints(), max_age_);
+
+      FILE *f = tmpfile();
+      if (NULL == f) {
+        return new WebErrorPageReply(WebReply::HTTP_INTERNAL_SERVER_ERROR,
+            "cannot open tmp file: %s", strerror(errno));
+      }
+      GVC_t* gvc = gvContext();
+      Agraph_t* G = agmemread((char *)graph.c_str());
+      gvLayout(gvc, G, (char *)"dot");
+      gvRender(gvc, G, "png", f);
+      gvFreeLayout(gvc, G);
+      agclose(G);
+      gvFreeContext(gvc);
+
+      try {
+        DynamicFileWebReply *freply = new DynamicFileWebReply(f);
+        return freply;
+      } catch (fawkes::Exception &e) {
+        return new WebErrorPageReply(WebReply::HTTP_INTERNAL_SERVER_ERROR, *(e.begin()));
+      }
+
+    } else {
+      WebPageReply *r = new WebPageReply("SyncPoints");
+      r->append_body("<p><img src=\"%s/graph.png\" /></p>", baseurl_);
+      return r;
+    }
+
+    WebPageReply *r = new WebPageReply("SyncPoints");
+    r->append_body("<p>Hello World</p>");
+    return r;
+  } else {
+    return NULL;
+  }
+}
+
+/**
+ * Get DOT graph for all SyncPoints
+ * @param syncpoints The set of syncpoints to show
+ * @param max_age Show only SyncPoint calls which are younger than max_age
+ * @return string representation of DOT graph
+ */
+std::string
+WebviewSyncPointRequestProcessor::all_syncpoints_as_dot(
+  const std::set<RefPtr<SyncPoint>,SyncPointSetLessThan> syncpoints,
+  float max_age)
+{
+  std::stringstream graph;
+  graph << std::fixed; //fixed point notation
+  graph.precision(3); //3 decimal places
+  graph << "digraph { graph [fontsize=14]; "
+      << "node [fontsize=12]; edge [fontsize=12]; ";
+  graph.setf(std::ios::fixed, std::ios::floatfield);
+
+  for (std::set<RefPtr<SyncPoint>, SyncPointSetLessThan>::const_iterator sp_it = syncpoints.begin();
+      sp_it != syncpoints.end(); sp_it++) {
+    graph << "\"" << (*sp_it)->get_identifier() << "\""
+        << " [shape=box];";
+  }
+
+  for (std::set<RefPtr<SyncPoint>, SyncPointSetLessThan>::const_iterator sp_it = syncpoints.begin();
+      sp_it != syncpoints.end(); sp_it++) {
+    graph << "\"" << (*sp_it)->get_identifier() << "\";";
+
+    // EMIT CALLS
+    CircularBuffer<SyncPointCall> emit_calls = (*sp_it)->get_emit_calls();
+    // generate call stats
+    std::map<std::string, SyncPointCallStats> emit_call_stats;
+    for (CircularBuffer<SyncPointCall>::iterator emitcalls_it = emit_calls.begin();
+        emitcalls_it != emit_calls.end(); emitcalls_it++) {
+      // Remove the main thread from the graph, and also remove any emit calls
+      // to the SyncPoint "/" to improve the resulting graph.
+      // The main thread emits and waits for every hook, which adds a lot of
+      // uninteresting edges to the graph.
+      // Similarly, all emitters also emit "/", which is not interesting to see.
+      if (emitcalls_it->get_caller() == "FawkesMainThread" ||
+          (*sp_it)->get_identifier() == "/") {
+        continue;
+      }
+      emit_call_stats[emitcalls_it->get_caller()].update_calls(emitcalls_it->get_call_time());
+    }
+
+    for (std::map<std::string, SyncPointCallStats>::iterator emit_call_stats_it = emit_call_stats.begin();
+        emit_call_stats_it != emit_call_stats.end(); emit_call_stats_it++) {
+      float age = (Time() - emit_call_stats_it->second.get_last_call()).in_sec();
+      if (age < max_age) {
+      graph << "\"" << emit_call_stats_it->first << "\" -> \""
+          <<  (*sp_it)->get_identifier()
+          << "\"" << " [label=\""
+          << " freq=" << emit_call_stats_it->second.get_call_frequency() << "Hz"
+          << " age=" << age << "s"
+          << " #calls=" << emit_call_stats_it->second.get_num_calls()
+          << "\"" << "];";
+      }
+    }
+
+    // WAIT FOR ONE CALLS
+    CircularBuffer<SyncPointCall> wait_one_calls = (*sp_it)->get_wait_calls(SyncPoint::WAIT_FOR_ONE);
+    // generate call stats
+    std::map<std::string, SyncPointCallStats> wait_one_call_stats;
+    for (CircularBuffer<SyncPointCall>::iterator waitcalls_it = wait_one_calls.begin();
+        waitcalls_it != wait_one_calls.end(); waitcalls_it++) {
+      wait_one_call_stats[waitcalls_it->get_caller()].update_calls(*waitcalls_it);
+    }
+
+    for (std::map<std::string, SyncPointCallStats>::iterator wait_call_stats_it = wait_one_call_stats.begin();
+        wait_call_stats_it != wait_one_call_stats.end(); wait_call_stats_it++) {
+      if (wait_call_stats_it->first == "FawkesMainThread") {
+        continue;
+      }
+      float age = (Time() - wait_call_stats_it->second.get_last_call()).in_sec();
+      if (age < max_age) {
+        graph << "\"" << (*sp_it)->get_identifier() << "\"" << " -> "
+            << "\"" << wait_call_stats_it->first << "\"" << " [label=" << "\""
+            << " avg=" << wait_call_stats_it->second.get_waittime_average() <<  "s"
+            << " age=" << age << "s"
+            << " #calls=" << wait_call_stats_it->second.get_num_calls()
+            //          << " max=" << max_wait_time << "s"
+            << "\"";
+        if ((*sp_it)->watcher_is_waiting(wait_call_stats_it->first, SyncPoint::WAIT_FOR_ONE)) {
+          graph << ",color=\"red\"";
+        }
+        graph << ",style=dotted";
+        graph << "];";
+      }
+    }
+
+    // WAIT FOR ALL CALLS
+    CircularBuffer<SyncPointCall> wait_all_calls = (*sp_it)->get_wait_calls(SyncPoint::WAIT_FOR_ALL);
+    // generate call stats
+    std::map<std::string, SyncPointCallStats> wait_all_call_stats;
+    for (CircularBuffer<SyncPointCall>::iterator waitcalls_it = wait_all_calls.begin();
+        waitcalls_it != wait_all_calls.end(); waitcalls_it++) {
+      wait_all_call_stats[waitcalls_it->get_caller()].update_calls(*waitcalls_it);
+    }
+
+    for (std::map<std::string, SyncPointCallStats>::iterator wait_call_stats_it = wait_all_call_stats.begin();
+        wait_call_stats_it != wait_all_call_stats.end(); wait_call_stats_it++) {
+      if (wait_call_stats_it->first == "FawkesMainThread") {
+        continue;
+      }
+      float age = (Time() - wait_call_stats_it->second.get_last_call()).in_sec();
+      if (age < max_age) {
+        graph << "\"" << (*sp_it)->get_identifier() << "\"" << " -> "
+            << "\"" << wait_call_stats_it->first << "\"" << " [label=" << "\""
+            << " avg=" << wait_call_stats_it->second.get_waittime_average() <<  "s"
+            << " age=" << age << "s"
+            << " #calls=" << wait_call_stats_it->second.get_num_calls()
+            //<< " max=" << max_wait_time << "s"
+            << "\"";
+        if ((*sp_it)->watcher_is_waiting(wait_call_stats_it->first, SyncPoint::WAIT_FOR_ALL)) {
+          graph << ",color=\"red\"";
+        }
+        graph << ",style=dashed";
+        graph << "];";
+      }
+    }
+  }
+  // Visualize hook dependencies by directly adding edges from one hook to the
+  // next. This is necessary because we removed the main thread from the
+  // visualization, which makes sure that the hooks are started in the right
+  // order. To retain the dependencies between the hooks, add edges manually.
+  // Essentially, these edges represent the order that is guaranteed by the
+  // main thread.
+  // Note: this expects that
+  //   (1) pre loop is the first, post loop th last hook,
+  //   (2) no custom enum values (e.g. WAKEUP_HOOK_ACT = 5) are specified.
+  for (uint i = BlockedTimingAspect::WAKEUP_HOOK_PRE_LOOP;
+       i != BlockedTimingAspect::WAKEUP_HOOK_POST_LOOP;
+       i++) {
+    graph << "\""
+      << BlockedTimingAspect::blocked_timing_hook_to_end_syncpoint(
+        static_cast<BlockedTimingAspect::WakeupHook>(i)) << "\""
+      << " -> " << "\""
+      << BlockedTimingAspect::blocked_timing_hook_to_start_syncpoint(
+        static_cast<BlockedTimingAspect::WakeupHook>(i+1))
+      << "\";";
+  }
+  graph << "}";
+  return graph.str();
+}
diff --git a/src/plugins/webview/syncpoint_processor.h b/src/plugins/webview/syncpoint_processor.h
new file mode 100644
index 000000000..00c4041e1
--- /dev/null
+++ b/src/plugins/webview/syncpoint_processor.h
@@ -0,0 +1,59 @@
+
+/***************************************************************************
+ *  syncpoint_processor.h - Web request processor for SyncPoints
+ *
+ *  Created: Thu Aug 14 16:21:42 2014
+ *  Copyright  2014  Till Hofmann
+ *
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#ifndef __PLUGINS_WEBVIEW_SYNCPOINT_PROCESSOR_H_
+#define __PLUGINS_WEBVIEW_SYNCPOINT_PROCESSOR_H_
+
+#include <webview/request_processor.h>
+
+#include <core/utils/refptr.h>
+#include <syncpoint/syncpoint_manager.h>
+
+namespace fawkes {
+  class BlackBoard;
+  class Interface;
+}
+
+class WebviewSyncPointRequestProcessor : public fawkes::WebRequestProcessor
+{
+ public:
+  WebviewSyncPointRequestProcessor(const char *baseurl,
+    fawkes::SyncPointManager *syncpoint_manager, float max_age);
+  virtual ~WebviewSyncPointRequestProcessor();
+
+  virtual fawkes::WebReply * process_request(const fawkes::WebRequest *request);
+
+ protected:
+  std::string all_syncpoints_as_dot(
+    const std::set< fawkes::RefPtr<fawkes::SyncPoint>,
+                    fawkes::SyncPointSetLessThan > syncpoints,
+    float max_age);
+
+ private:
+  char *baseurl_;
+  size_t baseurl_len_;
+  fawkes::SyncPointManager *syncpoint_manager_;
+  float max_age_;
+
+};
+
+#endif
diff --git a/src/plugins/webview/webview_thread.cpp b/src/plugins/webview/webview_thread.cpp
index ee2d158e8..1b6a65576 100644
--- a/src/plugins/webview/webview_thread.cpp
+++ b/src/plugins/webview/webview_thread.cpp
@@ -24,6 +24,7 @@
 #include "blackboard_processor.h"
 #include "startpage_processor.h"
 #include "plugins_processor.h"
+#include "syncpoint_processor.h"
 #ifdef HAVE_TF
 #  include "tf_processor.h"
 #endif
@@ -61,6 +62,8 @@ const char *WebviewThread::PLUGINS_URL_PREFIX = "/plugins";
 const char *WebviewThread::TF_URL_PREFIX = "/tf";
 /** Prefix for the WebMJPEGRequestProcessor. */
 const char *WebviewThread::IMAGE_URL_PREFIX = "/images";
+/** Prefix for the SyncPointRequestProcessor. */
+const char *WebviewThread::SYNCPOINT_URL_PREFIX = "/syncpoints";
 
 /** @class WebviewThread "webview_thread.h"
  * Webview Thread.
@@ -156,6 +159,11 @@ WebviewThread::init()
     __cfg_access_log = config->get_string("/webview/access_log");
   } catch (Exception &e) {}
 
+  __cfg_syncpoint_max_age = 20.f;
+  try {
+    __cfg_syncpoint_max_age = config->get_float("/webview/syncpoints/max_age");
+  } catch (Exception &e) {}
+
 
   __cache_logger.clear();
 
@@ -216,6 +224,7 @@ WebviewThread::init()
   __static_processor     = new WebviewStaticRequestProcessor(STATIC_URL_PREFIX, static_dirs_cstr, logger);
   __blackboard_processor = new WebviewBlackBoardRequestProcessor(BLACKBOARD_URL_PREFIX, blackboard);
   __plugins_processor    = new WebviewPluginsRequestProcessor(PLUGINS_URL_PREFIX, plugin_manager);
+  __syncpoint_processor  = new WebviewSyncPointRequestProcessor(SYNCPOINT_URL_PREFIX, syncpoint_manager, __cfg_syncpoint_max_age);
 #ifdef HAVE_TF
   __tf_processor         = new WebviewTfRequestProcessor(TF_URL_PREFIX, tf_listener);
 #endif
@@ -227,6 +236,7 @@ WebviewThread::init()
   webview_url_manager->register_baseurl(STATIC_URL_PREFIX, __static_processor);
   webview_url_manager->register_baseurl(BLACKBOARD_URL_PREFIX, __blackboard_processor);
   webview_url_manager->register_baseurl(PLUGINS_URL_PREFIX, __plugins_processor);
+  webview_url_manager->register_baseurl(SYNCPOINT_URL_PREFIX, __syncpoint_processor);
 #ifdef HAVE_TF
   webview_url_manager->register_baseurl(TF_URL_PREFIX, __tf_processor);
 #endif
@@ -239,6 +249,7 @@ WebviewThread::init()
   webview_nav_manager->add_nav_entry(TF_URL_PREFIX, "TF");
 #endif
   webview_nav_manager->add_nav_entry(PLUGINS_URL_PREFIX, "Plugins");
+  webview_nav_manager->add_nav_entry(SYNCPOINT_URL_PREFIX, "SyncPoints");
 #ifdef HAVE_JPEG
   webview_nav_manager->add_nav_entry(IMAGE_URL_PREFIX, "Images");
 #endif
@@ -274,6 +285,7 @@ WebviewThread::finalize()
   webview_url_manager->unregister_baseurl(BLACKBOARD_URL_PREFIX);
   webview_url_manager->unregister_baseurl(PLUGINS_URL_PREFIX);
   webview_url_manager->unregister_baseurl(IMAGE_URL_PREFIX);
+  webview_url_manager->unregister_baseurl(SYNCPOINT_URL_PREFIX);
 
 #ifdef HAVE_TF
   webview_url_manager->unregister_baseurl(TF_URL_PREFIX);
@@ -281,6 +293,7 @@ WebviewThread::finalize()
 
   webview_nav_manager->remove_nav_entry(BLACKBOARD_URL_PREFIX);
   webview_nav_manager->remove_nav_entry(PLUGINS_URL_PREFIX);
+  webview_nav_manager->remove_nav_entry(SYNCPOINT_URL_PREFIX);
 #ifdef HAVE_TF
   webview_nav_manager->remove_nav_entry(TF_URL_PREFIX);
 #endif
@@ -298,6 +311,7 @@ WebviewThread::finalize()
   delete __blackboard_processor;
   delete __startpage_processor;
   delete __plugins_processor;
+  delete __syncpoint_processor;
 #ifdef HAVE_TF
   delete __tf_processor;
 #endif
diff --git a/src/plugins/webview/webview_thread.h b/src/plugins/webview/webview_thread.h
index 50365a892..7214e5a1b 100644
--- a/src/plugins/webview/webview_thread.h
+++ b/src/plugins/webview/webview_thread.h
@@ -36,6 +36,7 @@
 #ifdef HAVE_TF
 #  include <aspect/tf.h>
 #endif
+#include <aspect/syncpoint_manager.h>
 
 #include <logging/cache.h>
 
@@ -59,6 +60,7 @@ class WebviewTfRequestProcessor;
 #ifdef HAVE_JPEG
 class WebviewImageRequestProcessor;
 #endif
+class WebviewSyncPointRequestProcessor;
 
 class WebviewThread
 : public fawkes::Thread,
@@ -74,6 +76,7 @@ class WebviewThread
 #ifdef HAVE_TF
   public fawkes::TransformAspect,
 #endif
+  public fawkes::SyncPointManagerAspect,
   public fawkes::WebviewAspect
 {
  public:
@@ -89,6 +92,7 @@ class WebviewThread
   static const char *PLUGINS_URL_PREFIX;
   static const char *TF_URL_PREFIX;
   static const char *IMAGE_URL_PREFIX;
+  static const char *SYNCPOINT_URL_PREFIX;
 
  private:
   void ssl_create(const char *ssl_key_file, const char *ssl_cert_file);
@@ -115,6 +119,7 @@ class WebviewThread
   WebviewHeaderGenerator             *__header_gen;
   WebviewFooterGenerator             *__footer_gen;
   WebviewUserVerifier                *__user_verifier;
+  WebviewSyncPointRequestProcessor   *__syncpoint_processor;
 
   unsigned int __cfg_port;
   bool         __cfg_use_ipv4;
@@ -127,6 +132,7 @@ class WebviewThread
   bool         __cfg_use_basic_auth;
   std::string  __cfg_basic_auth_realm;
   std::string  __cfg_access_log;
+  float        __cfg_syncpoint_max_age;
 
   fawkes::CacheLogger     __cache_logger;
   fawkes::NetworkService *__webview_service;
diff --git a/src/tools/Makefile b/src/tools/Makefile
index a0625f5c8..749923b6d 100644
--- a/src/tools/Makefile
+++ b/src/tools/Makefile
@@ -17,7 +17,7 @@ BASEDIR = ../..
 
 SUBDIRS = plugin logview config plugin_gui netloggui \
 	  lasergui skillgui battery_monitor ffinfo vision set_pose \
-		eclipse_debugger plugin_generator
+		eclipse_debugger plugin_generator laser_calibration
 
 include $(BASEDIR)/etc/buildsys/config.mk
 include $(BUILDSYSDIR)/rules.mk
diff --git a/src/tools/laser_calibration/Makefile b/src/tools/laser_calibration/Makefile
new file mode 100644
index 000000000..e6a8293c2
--- /dev/null
+++ b/src/tools/laser_calibration/Makefile
@@ -0,0 +1,59 @@
+#*****************************************************************************
+#                      Makefile Build System for Fawkes
+#                            -------------------
+#   Created on Mon 10 Jul 2017 18:16:01 CEST
+#   Copyright (C) 2017 by Till Hofmann <hofmann@kbsg.rwth-aachen.de>
+#
+#*****************************************************************************
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#*****************************************************************************
+
+BASEDIR = ../../..
+include $(BASEDIR)/etc/buildsys/config.mk
+include $(BUILDSYSDIR)/pcl.mk
+include $(BUILDCONFDIR)/tf/tf.mk
+
+LIBS_laser_calibration = stdc++ m fawkescore fawkesutils fawkesblackboard \
+		fawkesconfig fawkesinterface fawkesnetcomm fawkestf fawkespcl_utils \
+		Laser360Interface Laser720Interface Laser1080Interface MotorInterface
+
+OBJS_laser_calibration = laser_calibration.o
+OBJS_all = $(OBJS_laser_calibration)
+
+REQUIRED_PCL_LIBS = common filters registration
+
+ifeq ($(HAVE_TF),1)
+  ifeq ($(HAVE_PCL),1)
+    ifeq ($(call pcl-have-libs,$(REQUIRED_PCL_LIBS)),1)
+      CFLAGS += $(CFLAGS_PCL) $(call pcl-libs-cflags,$(REQUIRED_PCL_LIBS)) \
+                $(CFLAGS_TF)
+      LDFLAGS += $(LDFLAGS_PCL) $(call pcl-libs-ldflags,$(REQUIRED_PCL_LIBS)) \
+                 $(LDFLAGS_TF)
+      BINS_all += $(BINDIR)/laser_calibration
+    else
+      WARN_TARGETS += warning_pcl_libs
+    endif
+  else
+    WARN_TARGETS += warning_pcl
+  endif
+else
+  WARN_TARGETS += warning_tf
+endif
+
+ifeq ($(OBJSSUBMAKE),1)
+all: $(WARN_TARGETS)
+.PHONY: warning_tf warning_pcl warning_pcl_libs
+warning_tf:
+	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting laser calibration tool (TF not available)"
+warning_pcl:
+	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting laser calibration tool (PCL not available)"
+warning_pcl_libs:
+	$(SILENT)echo -e "$(INDENT_PRINT)--> $(TRED)Omitting laser calibration tool (not all PCL libs available, required: $(REQUIRED_PCL_LIBS))"
+endif
+
+include $(BUILDSYSDIR)/base.mk
diff --git a/src/tools/laser_calibration/laser_calibration.cpp b/src/tools/laser_calibration/laser_calibration.cpp
new file mode 100644
index 000000000..097bdef8f
--- /dev/null
+++ b/src/tools/laser_calibration/laser_calibration.cpp
@@ -0,0 +1,733 @@
+/***************************************************************************
+ *  laser_calibration.cpp - Tool to calibrate laser transforms
+ *
+ *  Created: Mon 10 Jul 2017 17:37:21 CEST 17:37
+ *  Copyright  2017  Till Hofmann <hofmann@kbsg.rwth-aachen.de>
+ ****************************************************************************/
+
+/*  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  Read the full text in the LICENSE.GPL file in the doc directory.
+ */
+
+#include <utils/system/argparser.h>
+
+#include <core/exception.h>
+#include <blackboard/remote.h>
+#include <config/netconf.h>
+#include <netcomm/fawkes/client.h>
+#include <tf/transformer.h>
+#include <tf/transform_listener.h>
+#include <interfaces/Laser360Interface.h>
+#include <interfaces/Laser720Interface.h>
+#include <interfaces/MotorInterface.h>
+#include <utils/hungarian_method/hungarian.h>
+
+#include <pcl/point_cloud.h>
+#include <pcl/point_types.h>
+#include <pcl/filters/filter.h>
+#include <pcl/filters/passthrough.h>
+#include <pcl/common/geometry.h>
+#include <pcl/registration/icp.h>
+
+#include <string>
+#include <map>
+#include <numeric>
+#include <random>
+#include <limits>
+
+#include <cmath>
+
+using namespace fawkes;
+using namespace std;
+
+typedef pcl::PointXYZ Point;
+typedef pcl::PointCloud<Point> PointCloud;
+typedef PointCloud::Ptr PointCloudPtr;
+typedef Laser360Interface LaserInterface;
+
+void
+print_usage(const char *program_name)
+{
+  printf("Usage: %s [-h] [-r host[:port]]\n"
+      " -h                 This help message\n"
+      " -r host[:port]     Remote host (and optionally port) to connect to\n"
+      " -f front-laser-id  The ID of the front laser blackboard interface\n"
+      " -b back-laser-id   The ID of the back laser blackboard interface\n"
+      " -R                 Skip roll calibration\n"
+      " -P                 Skip pitch calibration\n"
+      " -Y                 Skip yaw calibration\n"
+      " -T                 Skip time offset calibration\n",
+      program_name);
+}
+
+inline float
+deg2rad(float deg)
+{
+  return (deg * M_PI / 180.f);
+}
+
+class InsufficientDataException : public Exception
+{
+public:
+  InsufficientDataException(const char *error) : Exception(error) {}
+};
+
+class LaserCalibration
+{
+public:
+  LaserCalibration(LaserInterface *laser, tf::Transformer *tf_transformer,
+      NetworkConfiguration *config, string config_path)
+: laser_(laser), tf_transformer_(tf_transformer), config_(config),
+  config_path_(config_path) {}
+  virtual ~LaserCalibration() {}
+
+  virtual void calibrate() = 0;
+
+protected:
+  PointCloudPtr
+  laser_to_pointcloud(const LaserInterface &laser) {
+    PointCloudPtr cloud = PointCloudPtr(new PointCloud());
+    cloud->points.resize(laser.maxlenof_distances());
+    cloud->header.frame_id = laser.frame();
+    cloud->height = 1;
+    cloud->width = laser.maxlenof_distances();
+    float const *distances = laser.distances();
+    for (uint i = 0; i < laser.maxlenof_distances(); i++) {
+      cloud->points[i].x = distances[i]
+          * cosf(deg2rad(i) * (360. / laser.maxlenof_distances()));
+      cloud->points[i].y = distances[i]
+          * sinf(deg2rad(i) * (360. / laser.maxlenof_distances()));
+    }
+    return cloud;
+  }
+  void
+  transform_pointcloud(const string &target_frame, PointCloudPtr cloud) {
+    for (auto &point : cloud->points) {
+     tf::Stamped<tf::Point> point_in_laser_frame(
+         tf::Point(point.x, point.y, point.z),
+         fawkes::Time(0., cloud->header.stamp), cloud->header.frame_id);
+     tf::Stamped<tf::Point> point_in_base_frame;
+     tf_transformer_->transform_point(
+         target_frame, point_in_laser_frame, point_in_base_frame);
+     point.x = static_cast<float>(point_in_base_frame[0]);
+     point.y = static_cast<float>(point_in_base_frame[1]);
+     point.z = static_cast<float>(point_in_base_frame[2]);
+    }
+  }
+  PointCloudPtr filter_cloud_in_rear(PointCloudPtr input) {
+    pcl::PassThrough<Point> pass;
+    pass.setInputCloud(input);
+    pass.setFilterFieldName("x");
+    pass.setFilterLimits(-2., -0.8);
+    PointCloudPtr output(new PointCloud());
+    pass.filter(*output);
+    return output;
+  }
+  float get_mean_z(PointCloudPtr cloud) {
+    if (cloud->points.size() < min_points) {
+      stringstream error;
+      error << "Not enough laser points in rear cloud, got "
+            << cloud->size() << ", need " << min_points;
+      throw InsufficientDataException(error.str().c_str());
+    }
+    vector<float> zs;
+    zs.resize(cloud->points.size());
+    for (auto &point : *cloud) {
+      zs.push_back(point.z);
+    }
+    return accumulate(zs.begin(), zs.end(), 0.) / zs.size();
+  }
+  PointCloudPtr filter_left_cloud(PointCloudPtr input) {
+    pcl::PassThrough<Point> pass;
+    pass.setInputCloud(input);
+    pass.setFilterFieldName("y");
+    pass.setFilterLimits(0., 2.);
+    PointCloudPtr output(new PointCloud());
+    pass.filter(*output);
+    return output;
+  }
+  PointCloudPtr filter_right_cloud(PointCloudPtr input) {
+    pcl::PassThrough<Point> pass;
+    pass.setInputCloud(input);
+    pass.setFilterFieldName("y");
+    pass.setFilterLimits(-2., 0.);
+    PointCloudPtr output(new PointCloud());
+    pass.filter(*output);
+    return output;
+  }
+  PointCloudPtr filter_out_ground(PointCloudPtr input) {
+    pcl::PassThrough<Point> pass;
+    pass.setInputCloud(input);
+    pass.setFilterFieldName("z");
+    pass.setFilterLimits(0.1, 1);
+    PointCloudPtr output(new PointCloud());
+    pass.filter(*output);
+    return output;
+  }
+  float get_matching_cost(
+      PointCloudPtr cloud1, PointCloudPtr cloud2, float *rot_yaw)
+  {
+    if (cloud1->points.size() < min_points || cloud2->points.size() < min_points) {
+      stringstream error;
+      error << "Not enough points, got " << cloud1->points.size() << " and "
+          << cloud2->points.size() << " points, need " << min_points;
+      throw InsufficientDataException(error.str().c_str());
+    }
+    pcl::IterativeClosestPoint<Point, Point> icp;
+    icp.setInputCloud(cloud2);
+    icp.setInputTarget(cloud1);
+    PointCloud final;
+    icp.align(final);
+    if (!icp.hasConverged()) {
+      throw InsufficientDataException("ICP did not converge.");
+    }
+    if (rot_yaw) {
+      pcl::Registration<Point, Point, float>::Matrix4 transformation =
+          icp.getFinalTransformation();
+      *rot_yaw = atan2(transformation(1,0), transformation(0,0));
+    }
+    return icp.getFitnessScore();
+  }
+  PointCloudPtr filter_center_cloud(PointCloudPtr input) {
+    pcl::PassThrough<Point> pass_x;
+    pass_x.setInputCloud(input);
+    pass_x.setFilterFieldName("x");
+    pass_x.setFilterLimits(-2, 2);
+    PointCloudPtr x_filtered(new PointCloud());
+    pass_x.filter(*x_filtered);
+    pcl::PassThrough<Point> pass_y;;
+    pass_y.setInputCloud(x_filtered);
+    pass_y.setFilterFieldName("y");
+    pass_y.setFilterLimitsNegative(true);
+    pass_y.setFilterLimits(-0.5,0.5);
+    PointCloudPtr xy_filtered_inner(new PointCloud());
+    pass_y.filter(*xy_filtered_inner);
+    pcl::PassThrough<Point> pass_y_outer;
+    pass_y_outer.setInputCloud(xy_filtered_inner);
+    pass_y_outer.setFilterFieldName("y");
+    pass_y_outer.setFilterLimits(-3,3);
+    PointCloudPtr xy_filtered(new PointCloud());
+    pass_y_outer.filter(*xy_filtered);
+    pcl::PassThrough<Point> pass_z;
+    pass_z.setInputCloud(xy_filtered);
+    pass_z.setFilterFieldName("z");
+    pass_z.setFilterLimits(0.1, 1);
+    PointCloudPtr xyz_filtered(new PointCloud());
+    pass_z.filter(*xyz_filtered);
+    return xyz_filtered;
+  }
+
+protected:
+  LaserInterface *laser_;
+  tf::Transformer *tf_transformer_;
+  NetworkConfiguration *config_;
+  const string config_path_;
+  const static long sleep_time_ = 50000;
+  const static uint max_iterations_ = 100;
+  const static size_t min_points = 10;
+};
+
+class RollCalibration : public LaserCalibration
+{
+public:
+  RollCalibration(LaserInterface *laser, tf::Transformer *tf_transformer,
+      NetworkConfiguration *config, string config_path)
+  : LaserCalibration(laser, tf_transformer, config, config_path) {}
+
+  virtual void calibrate() {
+    printf("Starting to calibrate roll angle.\n");
+    float lrd = 2 * threshold;
+    uint iterations = 0;
+    do {
+      try {
+        lrd = get_lr_mean_diff();
+      } catch (InsufficientDataException &e) {
+        printf("Insufficient data: %s\n", e.what_no_backtrace());
+        usleep(sleep_time_);
+        continue;
+      }
+      printf("Left-right difference is %f.\n", lrd);
+      float old_roll = config_->get_float(config_path_.c_str());
+      float new_roll = get_new_roll(lrd, old_roll);
+      printf("Updating roll from %f to %f.\n", old_roll, new_roll);
+      config_->set_float(config_path_.c_str(), new_roll);
+      usleep(sleep_time_);
+    } while (abs(lrd) > threshold && ++iterations < max_iterations_);
+    printf("Roll calibration finished.\n");
+  }
+
+
+protected:
+  float get_lr_mean_diff() {
+    laser_->read();
+    PointCloudPtr cloud = laser_to_pointcloud(*laser_);
+    PointCloudPtr calib_cloud = filter_calibration_cloud(cloud);
+    transform_pointcloud("base_link", cloud);
+    PointCloudPtr rear_cloud = filter_cloud_in_rear(cloud);
+    PointCloudPtr left_cloud = filter_left_cloud(rear_cloud);
+    PointCloudPtr right_cloud = filter_right_cloud(rear_cloud);
+    if (left_cloud->size() < min_points) {
+      stringstream error;
+      error << "Not enough laser points on the left, got "
+            << left_cloud->size() << ", need " << min_points;
+      throw InsufficientDataException(error.str().c_str());
+    }
+    if (right_cloud->size() < min_points) {
+      stringstream error;
+      error << "Not enough laser points on the right, got "
+            << right_cloud->size() << ", need " << min_points;
+      throw InsufficientDataException(error.str().c_str());
+    }
+    printf("Using %zu points on the left, %zu points on the right\n",
+        left_cloud->size(), right_cloud->size());
+    return get_mean_z(left_cloud) - get_mean_z(right_cloud);
+  }
+  float get_new_roll(float mean_error, float old_roll) {
+    return old_roll + 0.5 * mean_error;
+  }
+  PointCloudPtr filter_calibration_cloud(PointCloudPtr input) {
+    PointCloudPtr filtered(new PointCloud());
+    std::vector<int> indices;
+    input->is_dense = false;
+    pcl::removeNaNFromPointCloud(*input, *filtered, indices);
+    return filtered;
+  }
+
+protected:
+  // TODO: make threshold and min_points configurable
+  constexpr static float threshold = 0.00001;
+};
+
+class PitchCalibration : public LaserCalibration
+{
+public:
+  PitchCalibration(LaserInterface *laser, tf::Transformer *tf_transformer,
+      NetworkConfiguration *config, string config_path)
+  : LaserCalibration(laser, tf_transformer, config, config_path) {}
+  virtual void calibrate() {
+    printf("Starting pitch angle calibration.\n");
+    float mean_z;
+    do {
+      laser_->read();
+      PointCloudPtr cloud = laser_to_pointcloud(*laser_);
+      transform_pointcloud("base_link", cloud);
+      PointCloudPtr rear_cloud = filter_cloud_in_rear(cloud);
+      printf("Rear cloud has %zu points.\n", rear_cloud->points.size());
+      try {
+        mean_z = get_mean_z(rear_cloud);
+      } catch (InsufficientDataException &e) {
+        printf("Insufficient data: %s\n", e.what_no_backtrace());
+        usleep(sleep_time_);
+        continue;
+      }
+      printf("Mean z is %f.\n", mean_z);
+      float old_pitch = config_->get_float(config_path_.c_str());
+      float new_pitch = get_new_pitch(mean_z, old_pitch);
+      printf("Updating pitch from %f to %f.\n", old_pitch, new_pitch);
+      config_->set_float(config_path_.c_str(), new_pitch);
+      usleep(sleep_time_);
+    } while (abs(mean_z) > threshold);
+    printf("Pitch calibration finished.\n");
+  }
+protected:
+  float get_new_pitch(float z, float old_pitch) {
+    // Note: We could also compute a more accurate new value using the measured
+    // distance and height, but this works well enough.
+    return old_pitch - z;
+  }
+protected:
+  constexpr static float threshold = 0.001;
+};
+
+class YawCalibration : public LaserCalibration
+{
+public:
+  YawCalibration(LaserInterface *laser, LaserInterface *front_laser,
+      tf::Transformer *tf_transformer, NetworkConfiguration *config,
+      string config_path)
+  : LaserCalibration(laser, tf_transformer, config, config_path),
+    front_laser_(front_laser), step_(init_step_), random_float_dist(0,1),
+    min_cost_(numeric_limits<float>::max()), min_cost_yaw_(0.) {}
+  virtual void calibrate() {
+    printf("Starting to calibrate yaw angle.\n");
+    float current_cost;
+    while (true) {
+      try {
+        current_cost = get_current_cost(NULL);
+        break;
+      } catch (InsufficientDataException &e) {
+        printf("Insufficient data, please move the robot\n");
+      }
+    }
+    uint iterations = 0;
+    float last_yaw = config_->get_float(config_path_.c_str());
+    min_cost_ = current_cost;
+    min_cost_yaw_ = last_yaw;
+    while (abs(step_) > 0.0005 && iterations++ < max_iterations_) {
+      float next_yaw;
+      try {
+        current_cost = get_current_cost(&step_);
+        next_yaw = last_yaw + step_;
+        if (current_cost < min_cost_) {
+          min_cost_ = current_cost;
+          min_cost_yaw_ = last_yaw;
+        }
+      } catch (InsufficientDataException &e) {
+        printf("Insufficient data, skipping loop.\n");
+        continue;
+      }
+      printf("Updating yaw from %f to %f (step %f), last cost %f\n",
+          last_yaw, next_yaw, step_, current_cost);
+      config_->set_float(config_path_.c_str(), next_yaw);
+      last_yaw = next_yaw;
+      usleep(sleep_time_);
+    }
+    if (current_cost > min_cost_) {
+      printf("Setting yaw to %f with minimal cost %f\n",
+          min_cost_yaw_, min_cost_);
+      config_->set_float(config_path_.c_str(), min_cost_yaw_);
+    }
+    printf("Yaw calibration finished.\n");
+  }
+protected:
+  float get_current_cost(float *new_yaw) {
+    front_laser_->read();
+    laser_->read();
+    PointCloudPtr front_cloud = laser_to_pointcloud(*front_laser_);
+    PointCloudPtr back_cloud = laser_to_pointcloud(*laser_);
+    transform_pointcloud("base_link", front_cloud);
+    transform_pointcloud("base_link", back_cloud);
+    front_cloud = filter_center_cloud(front_cloud);
+    back_cloud = filter_center_cloud(back_cloud);
+    return get_matching_cost(front_cloud, back_cloud, new_yaw);
+  }
+  float get_new_yaw(float current_cost, float last_yaw) {
+    static float last_cost = current_cost;
+    costs_[last_yaw] = current_cost;
+    float next_yaw = last_yaw + step_;
+    for (auto &cost_pair : costs_) {
+      if (cost_pair.second < current_cost && cost_pair.first != last_yaw) {
+        float jump_probability =
+            static_cast<float>((current_cost - cost_pair.second)) / current_cost;
+        float rand_01 = random_float_dist(random_generator_);
+        if (rand_01 > 1 - jump_probability) {
+          last_cost = current_cost;
+          if (random_float_dist(random_generator_) >= 0.5) {
+            step_ = init_step_;
+          } else {
+            step_ = -init_step_;
+          }
+          printf("Jumping to %f, cost %f -> %f (probability was %f)\n",
+              cost_pair.first, current_cost, cost_pair.second, jump_probability);
+          return cost_pair.first;
+        }
+      }
+    }
+    if (current_cost > last_cost) {
+      step_ = -step_/2;
+    }
+    last_cost = current_cost;
+    return next_yaw;
+  }
+
+protected:
+  LaserInterface *front_laser_;
+  const float init_step_ = 0.02;
+  float step_;
+  mt19937 random_generator_;
+  uniform_real_distribution<float> random_float_dist;
+  map<float, float> costs_;
+  float min_cost_;
+  float min_cost_yaw_;
+};
+
+class TimeOffsetCalibration : public LaserCalibration
+{
+public:
+  TimeOffsetCalibration(LaserInterface *laser, MotorInterface *motor,
+      tf::Transformer *tf_transformer,
+      NetworkConfiguration *config, string config_path)
+  : LaserCalibration(laser, tf_transformer, config, config_path),
+    motor_(motor),
+    step_(numeric_limits<float>::max())
+  {}
+
+  virtual void calibrate() {
+    float current_offset = config_->get_float(config_path_.c_str());
+    map<float, float> costs;
+    float min_cost = numeric_limits<float>::max();
+    float min_offset = 0.;
+    mt19937 random_gen;
+    uniform_real_distribution<float> random_float_dist(0, 1);
+    do {
+      printf("Rotating bot with omega %f\n", omega_);
+      for (uint i = 0; i < rotation_time_ * frequency_; i++) {
+        MotorInterface::TransRotMessage *rot_message =
+            new MotorInterface::TransRotMessage(0.f, 0.f, omega_);
+        motor_->msgq_enqueue(rot_message);
+        usleep(1e6/frequency_);
+        motor_->read();
+        if (motor_->omega() < 0.8 * omega_) {
+          i = 0;
+        }
+      }
+      printf("Taking snapshot (moving)\n");
+      PointCloudPtr moving_cloud = get_lasercloud(laser_);
+      MotorInterface::TransRotMessage *stop_message =
+          new MotorInterface::TransRotMessage(0.f, 0.f, 0.f);
+      printf("Stopping bot.\n");
+      motor_->msgq_enqueue(stop_message);
+      while (motor_->omega() > 0.02) {
+        motor_->read();
+      }
+      usleep(50000);
+      printf("Taking snapshot (resting)\n");
+      PointCloudPtr rest_cloud;
+      try {
+        rest_cloud = get_lasercloud(laser_);
+      } catch (Exception &e) {
+        printf("Cloud not get pointcloud: %s\n", e.what_no_backtrace());
+        continue;
+      }
+      float yaw;
+      float current_cost;
+      try {
+        current_cost = get_matching_cost(rest_cloud, moving_cloud, &yaw);
+      } catch (InsufficientDataException &e) {
+        printf("Insufficient data: %s.\nPlease move the robot.\n",
+            e.what_no_backtrace());
+        continue;
+      }
+      float next_offset;
+      float jump_probability =
+          static_cast<float>((current_cost - min_cost)) / current_cost;
+      float rand_01 = random_float_dist(random_gen);
+      if (current_cost > min_cost && rand_01 > 1 - jump_probability) {
+        printf("Setting back to minimum: %f -> %f (probability %f)\n",
+            current_offset, min_offset, jump_probability);
+        next_offset = min_offset;
+        step_ = next_offset - current_offset;
+      }  else {
+        min_cost = current_cost;
+        min_offset = current_offset;
+        step_ = -0.05 * yaw / omega_;
+        next_offset = current_offset + step_;
+      }
+      printf("Updating time offset from %f to %f (step %f), current cost %f\n",
+          current_offset, next_offset, step_, current_cost);
+      config_->set_float(config_path_.c_str(), next_offset);
+      current_offset = next_offset;
+      usleep(sleep_time_);
+    } while (abs(step_) > 0.0005);
+    printf("Setting to offset with minimal cost %f\n", min_offset);
+    config_->set_float(config_path_.c_str(), min_offset);
+  }
+protected:
+  PointCloudPtr get_lasercloud(LaserInterface *laser) {
+    laser->read();
+    PointCloudPtr laser_cloud = laser_to_pointcloud(*laser);
+    transform_pointcloud("odom", laser_cloud);
+    pcl::PassThrough<Point> pass_x;
+    pass_x.setInputCloud(laser_cloud);
+    pass_x.setFilterFieldName("x");
+    pass_x.setFilterLimits(-3., 3.);
+    PointCloudPtr x_filtered(new PointCloud());
+    pass_x.filter(*x_filtered);
+    pcl::PassThrough<Point> pass_y;;
+    pass_y.setInputCloud(x_filtered);
+    pass_y.setFilterFieldName("y");
+    pass_y.setFilterLimitsNegative(true);
+    pass_y.setFilterLimits(-0.3, 0.3);
+    PointCloudPtr xy_filtered_inner(new PointCloud());
+    pass_y.filter(*xy_filtered_inner);
+    pcl::PassThrough<Point> pass_y_outer;
+    pass_y_outer.setInputCloud(xy_filtered_inner);
+    pass_y_outer.setFilterFieldName("y");
+    pass_y_outer.setFilterLimits(-3,3);
+    PointCloudPtr xy_filtered(new PointCloud());
+    pass_y_outer.filter(*xy_filtered);
+    pcl::PassThrough<Point> pass_z;
+    pass_z.setInputCloud(xy_filtered);
+    pass_z.setFilterFieldName("z");
+    pass_z.setFilterLimits(0.1, 1);
+    PointCloudPtr xyz_filtered(new PointCloud());
+    pass_z.filter(*xyz_filtered);
+    return xyz_filtered;
+  }
+protected:
+  const static long sleep_time_ = 2000000;
+  MotorInterface *motor_;
+  constexpr static float omega_ = 2.0;
+  const static unsigned int frequency_ = 100;
+  constexpr static float rotation_time_ = 1.;
+  float step_;
+};
+
+int
+main(int argc, char **argv)
+{
+  ArgumentParser arg_parser(argc, argv, "hr:f:b:RPYT");
+  if (arg_parser.has_arg("h")) {
+    print_usage(argv[0]);
+    return 0;
+  }
+
+  FawkesNetworkClient *client = NULL;
+  BlackBoard *blackboard = NULL;
+  NetworkConfiguration *netconf = NULL;
+  tf::Transformer *transformer = NULL;
+  // Mark the tf listener as unused, we only use its callbacks.
+  tf::TransformListener *tf_listener __attribute__((unused)) = NULL;
+
+
+  string host = "localhost";
+  unsigned short int port = FAWKES_TCP_PORT;
+  if (arg_parser.has_arg("r")) {
+    arg_parser.parse_hostport("r", host, port);
+  }
+  string front_laser_interface_id = "Laser front 360";
+  if (arg_parser.has_arg("f")) {
+    front_laser_interface_id = string(arg_parser.arg("f"));
+  }
+  string back_laser_interface_id = "Laser back 360";
+  if (arg_parser.has_arg("b")) {
+    back_laser_interface_id = string(arg_parser.arg("b"));
+  }
+  bool calibrate_roll = true;
+  if (arg_parser.has_arg("R")) {
+    calibrate_roll = false;
+  }
+  bool calibrate_pitch = true;
+  if (arg_parser.has_arg("P")) {
+    calibrate_pitch = false;
+  }
+  bool calibrate_yaw = true;
+  if (arg_parser.has_arg("Y")) {
+    calibrate_yaw = false;
+  }
+  bool calibrate_time_offset = true;
+  if (arg_parser.has_arg("T")) {
+    calibrate_time_offset = false;
+  }
+
+  try {
+    client = new FawkesNetworkClient(host.c_str(), port);
+    client->connect();
+    blackboard = new RemoteBlackBoard(client);
+    netconf = new NetworkConfiguration(client);
+    transformer = new tf::Transformer();
+    tf_listener = new tf::TransformListener(blackboard, transformer, true);
+  } catch (Exception &e) {
+    printf("Failed to connect to remote host at %s:%u\n", host.c_str(), port);
+    e.print_trace();
+    return -1;
+  }
+
+  LaserInterface *laser = NULL;
+  try {
+    laser = blackboard->open_for_reading<LaserInterface>(
+        back_laser_interface_id.c_str());
+  } catch (Exception &e) {
+    printf("Failed to open Blackboard interface '%s'\n",
+        back_laser_interface_id.c_str());
+    e.print_trace();
+    return -1;
+  }
+  if (!laser->has_writer()) {
+    printf("Laser '%s' does not have a writer!\n",
+        back_laser_interface_id.c_str());
+    return -1;
+  }
+  LaserInterface *front_laser = NULL;
+  try {
+    front_laser = blackboard->open_for_reading<LaserInterface>(
+        front_laser_interface_id.c_str());
+  } catch (Exception &e) {
+    printf("Failed to open Blackboard interface '%s'\n",
+        front_laser_interface_id.c_str());
+    e.print_trace();
+    return -1;
+  }
+  if (!front_laser->has_writer()) {
+    printf("Laser '%s' does not have a writer!\n",
+        front_laser_interface_id.c_str());
+    return -1;
+  }
+  MotorInterface *motor = NULL;
+  string motor_interface_id = "Robotino";
+  try {
+    motor = blackboard->open_for_reading<MotorInterface>(
+        motor_interface_id.c_str());
+  } catch (Exception &e) {
+    printf("Failed to open Blackboard interface '%s'\n",
+        motor_interface_id.c_str());
+    e.print_trace();
+    return -1;
+  }
+  if (!motor->has_writer()) {
+    printf("motor '%s' does not have a writer!\n", motor_interface_id.c_str());
+    return -1;
+  }
+
+  const string cfg_transforms_prefix =
+      "/plugins/static-transforms/transforms/back_laser/";
+
+  RollCalibration roll_calibration(
+      laser, transformer, netconf, cfg_transforms_prefix + "rot_roll");
+  PitchCalibration pitch_calibration(
+      laser, transformer, netconf, cfg_transforms_prefix + "rot_pitch");
+  YawCalibration yaw_calibration(
+      laser, front_laser, transformer, netconf,
+      cfg_transforms_prefix + "rot_yaw");
+  // TODO: make config path a commandline argument
+  TimeOffsetCalibration time_offset_front_calibration(
+      front_laser, motor, transformer, netconf, "/hardware/laser/front/time_offset");
+  TimeOffsetCalibration time_offset_back_calibration(
+      laser, motor, transformer, netconf, "/hardware/laser/back/time_offset");
+  if (calibrate_pitch || calibrate_roll) {
+    cout << "Please put the robot in a position such that you only have ground "
+         << "behind the robot." << endl;
+  }
+  if (calibrate_pitch) {
+    cout << "To start pitch calibration, press enter" << endl;
+    cin.get();
+    pitch_calibration.calibrate();
+    printf("--------------------\n");
+  }
+  if (calibrate_roll) {
+    cout << "To start roll calibration, press enter" << endl;
+    cin.get();
+    roll_calibration.calibrate();
+    printf("--------------------\n");
+}
+  if (calibrate_yaw) {
+    cout << "Please move the robot such that it can see a wall." << endl
+         << "To start yaw calibration, press enter." << endl;
+    cin.get();
+    yaw_calibration.calibrate();
+    printf("--------------------\n");
+}
+  if (calibrate_time_offset) {
+    cout << "Move the robot into a corner and make sure that it can rotate "
+         << "without hitting any obstacles." << endl
+         << "Careful: The robot will start rotating in the next step." << endl
+         << "Press Enter to start time offset calibration." << endl;
+    cin.get();
+    printf("Starting time offset calibration for front laser.\n");
+    time_offset_front_calibration.calibrate();
+    printf("--------------------\n");
+    printf("Starting time offset calibration for back laser.\n");
+    time_offset_back_calibration.calibrate();
+  }
+
+  return 0;
+}
